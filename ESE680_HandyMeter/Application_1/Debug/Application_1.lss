
Application_1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001aa8  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .got          000000ac  00009aa8  00009aa8  00009aa8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .got.plt      0000000c  00009b54  00009b54  00009b54  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .relocate     0000000c  20000000  00009b60  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000278  20000010  00009b70  0001000c  2**4
                  ALLOC
  5 .stack        00002000  20000288  00009de8  0001000c  2**0
                  ALLOC
  6 .ARM.attributes 0000002a  00000000  00000000  0001000c  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  00010036  2**0
                  CONTENTS, READONLY
  8 .debug_info   00026170  00000000  00000000  0001008f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00003963  00000000  00000000  000361ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005678  00000000  00000000  00039b62  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000005b8  00000000  00000000  0003f1da  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000638  00000000  00000000  0003f792  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0001ab5b  00000000  00000000  0003fdca  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c56b  00000000  00000000  0005a925  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0008de41  00000000  00000000  00066e90  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00000eac  00000000  00000000  000f4cd4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <exception_table>:
    8000:	88 22 00 20 85 97 00 00 81 97 00 00 81 97 00 00     .". ............
	...
    802c:	81 97 00 00 00 00 00 00 00 00 00 00 81 97 00 00     ................
    803c:	81 97 00 00 81 97 00 00 81 97 00 00 81 97 00 00     ................
    804c:	11 86 00 00 d9 84 00 00 81 97 00 00 09 84 00 00     ................
    805c:	4d 90 00 00 81 97 00 00 5d 86 00 00 71 86 00 00     M.......]...q...
    806c:	85 86 00 00 99 86 00 00 ad 86 00 00 c1 86 00 00     ................
    807c:	81 97 00 00 81 97 00 00 81 97 00 00 81 97 00 00     ................
    808c:	81 97 00 00 81 97 00 00 00 00 00 00 00 00 00 00     ................
    809c:	81 97 00 00 81 97 00 00 81 97 00 00 81 97 00 00     ................
    80ac:	81 97 00 00 00 00 00 00                             ........

000080b4 <__do_global_dtors_aux>:
    80b4:	b510      	push	{r4, lr}
    80b6:	4c06      	ldr	r4, [pc, #24]	; (80d0 <__do_global_dtors_aux+0x1c>)
    80b8:	7823      	ldrb	r3, [r4, #0]
    80ba:	2b00      	cmp	r3, #0
    80bc:	d107      	bne.n	80ce <__do_global_dtors_aux+0x1a>
    80be:	4b05      	ldr	r3, [pc, #20]	; (80d4 <__do_global_dtors_aux+0x20>)
    80c0:	2b00      	cmp	r3, #0
    80c2:	d002      	beq.n	80ca <__do_global_dtors_aux+0x16>
    80c4:	4804      	ldr	r0, [pc, #16]	; (80d8 <__do_global_dtors_aux+0x24>)
    80c6:	e000      	b.n	80ca <__do_global_dtors_aux+0x16>
    80c8:	bf00      	nop
    80ca:	2301      	movs	r3, #1
    80cc:	7023      	strb	r3, [r4, #0]
    80ce:	bd10      	pop	{r4, pc}
    80d0:	20000010 	.word	0x20000010
    80d4:	00000000 	.word	0x00000000
    80d8:	00009aa8 	.word	0x00009aa8

000080dc <frame_dummy>:
    80dc:	4b08      	ldr	r3, [pc, #32]	; (8100 <frame_dummy+0x24>)
    80de:	b510      	push	{r4, lr}
    80e0:	2b00      	cmp	r3, #0
    80e2:	d003      	beq.n	80ec <frame_dummy+0x10>
    80e4:	4907      	ldr	r1, [pc, #28]	; (8104 <frame_dummy+0x28>)
    80e6:	4808      	ldr	r0, [pc, #32]	; (8108 <frame_dummy+0x2c>)
    80e8:	e000      	b.n	80ec <frame_dummy+0x10>
    80ea:	bf00      	nop
    80ec:	4807      	ldr	r0, [pc, #28]	; (810c <frame_dummy+0x30>)
    80ee:	6803      	ldr	r3, [r0, #0]
    80f0:	2b00      	cmp	r3, #0
    80f2:	d100      	bne.n	80f6 <frame_dummy+0x1a>
    80f4:	bd10      	pop	{r4, pc}
    80f6:	4b06      	ldr	r3, [pc, #24]	; (8110 <frame_dummy+0x34>)
    80f8:	2b00      	cmp	r3, #0
    80fa:	d0fb      	beq.n	80f4 <frame_dummy+0x18>
    80fc:	4798      	blx	r3
    80fe:	e7f9      	b.n	80f4 <frame_dummy+0x18>
    8100:	00000000 	.word	0x00000000
    8104:	20000014 	.word	0x20000014
    8108:	00009aa8 	.word	0x00009aa8
    810c:	00009aa8 	.word	0x00009aa8
    8110:	00000000 	.word	0x00000000

00008114 <main>:
#include <asf.h>
#include "application.h"

int main(void)
{
    8114:	b570      	push	{r4, r5, r6, lr}
    8116:	b084      	sub	sp, #16
    8118:	4d12      	ldr	r5, [pc, #72]	; (8164 <main+0x50>)
    811a:	447d      	add	r5, pc
	system_init();
    811c:	4b12      	ldr	r3, [pc, #72]	; (8168 <main+0x54>)
    811e:	58eb      	ldr	r3, [r5, r3]
    8120:	9301      	str	r3, [sp, #4]
    8122:	4798      	blx	r3
	delay_init();
    8124:	4b11      	ldr	r3, [pc, #68]	; (816c <main+0x58>)
    8126:	58eb      	ldr	r3, [r5, r3]
    8128:	9301      	str	r3, [sp, #4]
    812a:	4798      	blx	r3
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
	config->powersave  = false;
    812c:	2300      	movs	r3, #0
    812e:	a903      	add	r1, sp, #12
    8130:	708b      	strb	r3, [r1, #2]

	struct port_config cfg;
	port_get_config_defaults(&cfg);
	cfg.powersave = 0;
	cfg.direction = PORT_PIN_DIR_OUTPUT;
    8132:	2201      	movs	r2, #1
    8134:	700a      	strb	r2, [r1, #0]
	cfg.input_pull = PORT_PIN_PULL_NONE;
    8136:	704b      	strb	r3, [r1, #1]
	port_pin_set_config(LED_OUT_PIN, &cfg);
    8138:	202b      	movs	r0, #43	; 0x2b
    813a:	4b0d      	ldr	r3, [pc, #52]	; (8170 <main+0x5c>)
    813c:	58eb      	ldr	r3, [r5, r3]
    813e:	9301      	str	r3, [sp, #4]
    8140:	4798      	blx	r3

	bool state = 0;
    8142:	2400      	movs	r4, #0

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    8144:	4e0b      	ldr	r6, [pc, #44]	; (8174 <main+0x60>)
	while(1) {
		state = !state;
		port_pin_set_output_level(LED_OUT_PIN, state);
		delay_ms(100);
    8146:	4b0c      	ldr	r3, [pc, #48]	; (8178 <main+0x64>)
    8148:	58ed      	ldr	r5, [r5, r3]
    814a:	e004      	b.n	8156 <main+0x42>
    814c:	2380      	movs	r3, #128	; 0x80
    814e:	011b      	lsls	r3, r3, #4
    8150:	6173      	str	r3, [r6, #20]
    8152:	2064      	movs	r0, #100	; 0x64
    8154:	47a8      	blx	r5
		state = !state;
    8156:	2301      	movs	r3, #1
    8158:	405c      	eors	r4, r3
	if (level) {
    815a:	d0f7      	beq.n	814c <main+0x38>
		port_base->OUTSET.reg = pin_mask;
    815c:	2380      	movs	r3, #128	; 0x80
    815e:	011b      	lsls	r3, r3, #4
    8160:	61b3      	str	r3, [r6, #24]
    8162:	e7f6      	b.n	8152 <main+0x3e>
    8164:	0000198a 	.word	0x0000198a
    8168:	00000010 	.word	0x00000010
    816c:	00000050 	.word	0x00000050
    8170:	0000007c 	.word	0x0000007c
    8174:	41004480 	.word	0x41004480
    8178:	000000a0 	.word	0x000000a0

0000817c <system_board_init>:

#define CFG(x)	port_pin_set_config(x, &config)
#define LO(x)	port_pin_set_output_level(x,0)
#define HI(x)	port_pin_set_output_level(x,1)
void system_board_init(void)
{
    817c:	b5f0      	push	{r4, r5, r6, r7, lr}
    817e:	46c6      	mov	lr, r8
    8180:	b500      	push	{lr}
    8182:	b082      	sub	sp, #8
    8184:	4b50      	ldr	r3, [pc, #320]	; (82c8 <system_board_init+0x14c>)
    8186:	447b      	add	r3, pc
	config->direction  = PORT_PIN_DIR_INPUT;
    8188:	2600      	movs	r6, #0
    818a:	ac01      	add	r4, sp, #4
    818c:	7026      	strb	r6, [r4, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    818e:	2701      	movs	r7, #1
    8190:	7067      	strb	r7, [r4, #1]
	config->powersave  = false;
    8192:	70a6      	strb	r6, [r4, #2]

	// SD Card pins, all inputs pull-up
	config.direction	= PORT_PIN_DIR_INPUT;
	config.input_pull	= PORT_PIN_PULL_UP;
	config.powersave	= 0;
	CFG(SD_SPI_MOSI_PIN); CFG(SD_SPI_MISO_PIN); CFG(SD_SPI_SCK_PIN); CFG(SD_SPI_CS_PIN);
    8194:	0021      	movs	r1, r4
    8196:	2013      	movs	r0, #19
    8198:	4a4c      	ldr	r2, [pc, #304]	; (82cc <system_board_init+0x150>)
    819a:	589d      	ldr	r5, [r3, r2]
    819c:	47a8      	blx	r5
    819e:	0021      	movs	r1, r4
    81a0:	2010      	movs	r0, #16
    81a2:	47a8      	blx	r5
    81a4:	0021      	movs	r1, r4
    81a6:	2011      	movs	r0, #17
    81a8:	47a8      	blx	r5
    81aa:	0021      	movs	r1, r4
    81ac:	2012      	movs	r0, #18
    81ae:	47a8      	blx	r5
	
	// Logic inputs, all input pull-none
	config.direction	= PORT_PIN_DIR_INPUT;
    81b0:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_NONE;
    81b2:	7066      	strb	r6, [r4, #1]
	config.powersave	= 1;
    81b4:	70a7      	strb	r7, [r4, #2]
	CFG(LOGIC1_TC_CAP_PIN); CFG(LOGIC2_TC_CAP_PIN);
    81b6:	0021      	movs	r1, r4
    81b8:	2014      	movs	r0, #20
    81ba:	47a8      	blx	r5
    81bc:	0021      	movs	r1, r4
    81be:	2015      	movs	r0, #21
    81c0:	47a8      	blx	r5

	// USB / UART, both inputs pull-up
	config.direction	= PORT_PIN_DIR_INPUT;
    81c2:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_UP;
    81c4:	7067      	strb	r7, [r4, #1]
	config.powersave	= 1;
    81c6:	70a7      	strb	r7, [r4, #2]
	CFG(USB_DN_UART_TX_PIN); CFG(USB_DP_UART_RX_PIN);
    81c8:	0021      	movs	r1, r4
    81ca:	2018      	movs	r0, #24
    81cc:	47a8      	blx	r5
    81ce:	0021      	movs	r1, r4
    81d0:	2019      	movs	r0, #25
    81d2:	47a8      	blx	r5

	// External ADC pins, all inputs pull-down
	config.direction	= PORT_PIN_DIR_INPUT;
    81d4:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_DOWN;
    81d6:	2302      	movs	r3, #2
    81d8:	4698      	mov	r8, r3
    81da:	7063      	strb	r3, [r4, #1]
	config.powersave	= 1;
    81dc:	70a7      	strb	r7, [r4, #2]
	CFG(ADC_SPI_CS_PIN); CFG(ADC_SPI_MISO_PIN); CFG(ADC_SPI_MOSI_PIN); CFG(ADC_SPI_SCK_PIN); CFG(ADC_GCLK_MCK_PIN);
    81de:	0021      	movs	r1, r4
    81e0:	2036      	movs	r0, #54	; 0x36
    81e2:	47a8      	blx	r5
    81e4:	0021      	movs	r1, r4
    81e6:	2022      	movs	r0, #34	; 0x22
    81e8:	47a8      	blx	r5
    81ea:	0021      	movs	r1, r4
    81ec:	2037      	movs	r0, #55	; 0x37
    81ee:	47a8      	blx	r5
    81f0:	0021      	movs	r1, r4
    81f2:	2023      	movs	r0, #35	; 0x23
    81f4:	47a8      	blx	r5
    81f6:	0021      	movs	r1, r4
    81f8:	202a      	movs	r0, #42	; 0x2a
    81fa:	47a8      	blx	r5

	// Buttons, all inputs pull-none
	config.direction	= PORT_PIN_DIR_INPUT;
    81fc:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_UP;
    81fe:	7067      	strb	r7, [r4, #1]
	config.powersave	= 0;
    8200:	70a6      	strb	r6, [r4, #2]
	CFG(BUT1_IRQ_IN_PIN); CFG(BUT2_IRQ_IN_PIN);
    8202:	0021      	movs	r1, r4
    8204:	2003      	movs	r0, #3
    8206:	47a8      	blx	r5
    8208:	0021      	movs	r1, r4
    820a:	201f      	movs	r0, #31
    820c:	47a8      	blx	r5

	// Battery sense, input pull-none
	config.direction	= PORT_PIN_DIR_INPUT;
    820e:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_NONE;
    8210:	7066      	strb	r6, [r4, #1]
	config.powersave	= 1;
    8212:	70a7      	strb	r7, [r4, #2]
	CFG(BATSENSE_ADC_PIN);
    8214:	0021      	movs	r1, r4
    8216:	2002      	movs	r0, #2
    8218:	47a8      	blx	r5

	// LEDs, input pull-none
	config.direction	= PORT_PIN_DIR_INPUT;
    821a:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_NONE;
    821c:	7066      	strb	r6, [r4, #1]
	config.powersave	= 1;
    821e:	70a7      	strb	r7, [r4, #2]
	CFG(LED_OUT_PIN);
    8220:	0021      	movs	r1, r4
    8222:	202b      	movs	r0, #43	; 0x2b
    8224:	47a8      	blx	r5
	
	// Range switches, pull-down
	config.direction	= PORT_PIN_DIR_INPUT;
    8226:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_DOWN;
    8228:	4643      	mov	r3, r8
    822a:	7063      	strb	r3, [r4, #1]
	config.powersave	= 1;
    822c:	70a7      	strb	r7, [r4, #2]
	CFG(SW1A_GP_OUT_PIN); CFG(SW2A_GP_OUT_PIN); CFG(SW3A_GP_OUT_PIN); CFG(SW4A_GP_OUT_PIN);
    822e:	0021      	movs	r1, r4
    8230:	2004      	movs	r0, #4
    8232:	47a8      	blx	r5
    8234:	0021      	movs	r1, r4
    8236:	2005      	movs	r0, #5
    8238:	47a8      	blx	r5
    823a:	0021      	movs	r1, r4
    823c:	2006      	movs	r0, #6
    823e:	47a8      	blx	r5
    8240:	0021      	movs	r1, r4
    8242:	2007      	movs	r0, #7
    8244:	47a8      	blx	r5
	CFG(SW1B_GP_OUT_PIN); CFG(SW2B_GP_OUT_PIN); CFG(SW3B_GP_OUT_PIN); CFG(SW4B_GP_OUT_PIN);
    8246:	0021      	movs	r1, r4
    8248:	2008      	movs	r0, #8
    824a:	47a8      	blx	r5
    824c:	0021      	movs	r1, r4
    824e:	2009      	movs	r0, #9
    8250:	47a8      	blx	r5
    8252:	0021      	movs	r1, r4
    8254:	200a      	movs	r0, #10
    8256:	47a8      	blx	r5
    8258:	0021      	movs	r1, r4
    825a:	200b      	movs	r0, #11
    825c:	47a8      	blx	r5
	
	// Accessory power enable, drive low
	config.direction	= PORT_PIN_DIR_INPUT;
    825e:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_DOWN;
    8260:	4643      	mov	r3, r8
    8262:	7063      	strb	r3, [r4, #1]
	config.powersave	= 1;
    8264:	70a7      	strb	r7, [r4, #2]
	CFG(ACCYEN_GP_OUT_PIN);
    8266:	0021      	movs	r1, r4
    8268:	2017      	movs	r0, #23
    826a:	47a8      	blx	r5

	// ATWINC, input pull-down communication pins
	config.direction	= PORT_PIN_DIR_INPUT;
    826c:	7026      	strb	r6, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_DOWN;
    826e:	4643      	mov	r3, r8
    8270:	7063      	strb	r3, [r4, #1]
	config.powersave	= 1;
    8272:	70a7      	strb	r7, [r4, #2]
	CFG(WINC_SPI_CS_PIN); CFG(WINC_SPI_MISO_PIN); CFG(WINC_SPI_MOSI_PIN); CFG(WINC_SPI_SCK_PIN); CFG(WINC_SPI_INT_PIN); CFG(WINC_GCLK_RTC_PIN); CFG(WINC_WAKE_GP_OUT_PIN);
    8274:	0021      	movs	r1, r4
    8276:	200e      	movs	r0, #14
    8278:	47a8      	blx	r5
    827a:	0021      	movs	r1, r4
    827c:	200f      	movs	r0, #15
    827e:	47a8      	blx	r5
    8280:	0021      	movs	r1, r4
    8282:	200c      	movs	r0, #12
    8284:	47a8      	blx	r5
    8286:	0021      	movs	r1, r4
    8288:	200d      	movs	r0, #13
    828a:	47a8      	blx	r5
    828c:	0021      	movs	r1, r4
    828e:	2029      	movs	r0, #41	; 0x29
    8290:	47a8      	blx	r5
    8292:	0021      	movs	r1, r4
    8294:	2016      	movs	r0, #22
    8296:	47a8      	blx	r5
    8298:	0021      	movs	r1, r4
    829a:	2028      	movs	r0, #40	; 0x28
    829c:	47a8      	blx	r5
	
	// ATWINC, drive enable pins low
	config.direction	= PORT_PIN_DIR_OUTPUT;
    829e:	7027      	strb	r7, [r4, #0]
	config.input_pull	= PORT_PIN_PULL_NONE;
    82a0:	7066      	strb	r6, [r4, #1]
	config.powersave	= 0;
    82a2:	70a6      	strb	r6, [r4, #2]
		port_base->OUTCLR.reg = pin_mask;
    82a4:	4b0a      	ldr	r3, [pc, #40]	; (82d0 <system_board_init+0x154>)
    82a6:	2280      	movs	r2, #128	; 0x80
    82a8:	0512      	lsls	r2, r2, #20
    82aa:	615a      	str	r2, [r3, #20]
    82ac:	2280      	movs	r2, #128	; 0x80
    82ae:	0552      	lsls	r2, r2, #21
    82b0:	615a      	str	r2, [r3, #20]
	LO(WINC_RESET_GP_OUT_PIN);  LO(WINC_CHIPEN_GP_OUT_PIN);
	CFG(WINC_RESET_GP_OUT_PIN); CFG(WINC_CHIPEN_GP_OUT_PIN);
    82b2:	0021      	movs	r1, r4
    82b4:	201b      	movs	r0, #27
    82b6:	47a8      	blx	r5
    82b8:	0021      	movs	r1, r4
    82ba:	201c      	movs	r0, #28
    82bc:	47a8      	blx	r5
	
    82be:	b002      	add	sp, #8
    82c0:	bc04      	pop	{r2}
    82c2:	4690      	mov	r8, r2
    82c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82c6:	46c0      	nop			; (mov r8, r8)
    82c8:	0000191e 	.word	0x0000191e
    82cc:	0000007c 	.word	0x0000007c
    82d0:	41004400 	.word	0x41004400

000082d4 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    82d4:	b530      	push	{r4, r5, lr}
    82d6:	b083      	sub	sp, #12
    82d8:	4c0d      	ldr	r4, [pc, #52]	; (8310 <delay_init+0x3c>)
    82da:	447c      	add	r4, pc
	cycles_per_ms = system_gclk_gen_get_hz(0);
    82dc:	2000      	movs	r0, #0
    82de:	4b0d      	ldr	r3, [pc, #52]	; (8314 <delay_init+0x40>)
    82e0:	58e3      	ldr	r3, [r4, r3]
    82e2:	9301      	str	r3, [sp, #4]
    82e4:	4798      	blx	r3
    82e6:	0005      	movs	r5, r0
	cycles_per_ms /= 1000;
    82e8:	4b0b      	ldr	r3, [pc, #44]	; (8318 <delay_init+0x44>)
    82ea:	58e4      	ldr	r4, [r4, r3]
    82ec:	21fa      	movs	r1, #250	; 0xfa
    82ee:	0089      	lsls	r1, r1, #2
    82f0:	47a0      	blx	r4
    82f2:	4b0a      	ldr	r3, [pc, #40]	; (831c <delay_init+0x48>)
    82f4:	447b      	add	r3, pc
    82f6:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    82f8:	4909      	ldr	r1, [pc, #36]	; (8320 <delay_init+0x4c>)
    82fa:	0028      	movs	r0, r5
    82fc:	47a0      	blx	r4
    82fe:	4b09      	ldr	r3, [pc, #36]	; (8324 <delay_init+0x50>)
    8300:	447b      	add	r3, pc
    8302:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    8304:	2205      	movs	r2, #5
    8306:	4b08      	ldr	r3, [pc, #32]	; (8328 <delay_init+0x54>)
    8308:	601a      	str	r2, [r3, #0]
}
    830a:	b003      	add	sp, #12
    830c:	bd30      	pop	{r4, r5, pc}
    830e:	46c0      	nop			; (mov r8, r8)
    8310:	000017ca 	.word	0x000017ca
    8314:	00000038 	.word	0x00000038
    8318:	0000006c 	.word	0x0000006c
    831c:	1fff7d08 	.word	0x1fff7d08
    8320:	000f4240 	.word	0x000f4240
    8324:	1fff7d00 	.word	0x1fff7d00
    8328:	e000e010 	.word	0xe000e010

0000832c <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
    832c:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
    832e:	4b09      	ldr	r3, [pc, #36]	; (8354 <delay_cycles_ms+0x28>)
    8330:	447b      	add	r3, pc
    8332:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
    8334:	4a08      	ldr	r2, [pc, #32]	; (8358 <delay_cycles_ms+0x2c>)
		SysTick->VAL = 0;
    8336:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    8338:	2180      	movs	r1, #128	; 0x80
    833a:	0249      	lsls	r1, r1, #9
	while (n--) {
    833c:	3801      	subs	r0, #1
    833e:	d307      	bcc.n	8350 <delay_cycles_ms+0x24>
	if (n > 0) {
    8340:	2c00      	cmp	r4, #0
    8342:	d0fb      	beq.n	833c <delay_cycles_ms+0x10>
		SysTick->LOAD = n;
    8344:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
    8346:	6095      	str	r5, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    8348:	6813      	ldr	r3, [r2, #0]
    834a:	420b      	tst	r3, r1
    834c:	d0fc      	beq.n	8348 <delay_cycles_ms+0x1c>
    834e:	e7f5      	b.n	833c <delay_cycles_ms+0x10>
	}
}
    8350:	bd30      	pop	{r4, r5, pc}
    8352:	46c0      	nop			; (mov r8, r8)
    8354:	1fff7ccc 	.word	0x1fff7ccc
    8358:	e000e010 	.word	0xe000e010

0000835c <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
    835c:	b082      	sub	sp, #8
    835e:	4b12      	ldr	r3, [pc, #72]	; (83a8 <cpu_irq_enter_critical+0x4c>)
    8360:	447b      	add	r3, pc
	if (cpu_irq_critical_section_counter == 0) {
    8362:	4a12      	ldr	r2, [pc, #72]	; (83ac <cpu_irq_enter_critical+0x50>)
    8364:	447a      	add	r2, pc
    8366:	6812      	ldr	r2, [r2, #0]
    8368:	2a00      	cmp	r2, #0
    836a:	d107      	bne.n	837c <cpu_irq_enter_critical+0x20>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    836c:	f3ef 8210 	mrs	r2, PRIMASK
		if (cpu_irq_is_enabled()) {
    8370:	2a00      	cmp	r2, #0
    8372:	d00a      	beq.n	838a <cpu_irq_enter_critical+0x2e>
			cpu_irq_disable();
			cpu_irq_prev_interrupt_state = true;
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    8374:	2200      	movs	r2, #0
    8376:	4b0e      	ldr	r3, [pc, #56]	; (83b0 <cpu_irq_enter_critical+0x54>)
    8378:	447b      	add	r3, pc
    837a:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    837c:	4a0d      	ldr	r2, [pc, #52]	; (83b4 <cpu_irq_enter_critical+0x58>)
    837e:	447a      	add	r2, pc
    8380:	6813      	ldr	r3, [r2, #0]
    8382:	3301      	adds	r3, #1
    8384:	6013      	str	r3, [r2, #0]
}
    8386:	b002      	add	sp, #8
    8388:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
    838a:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    838c:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    8390:	4a09      	ldr	r2, [pc, #36]	; (83b8 <cpu_irq_enter_critical+0x5c>)
    8392:	589b      	ldr	r3, [r3, r2]
    8394:	9301      	str	r3, [sp, #4]
    8396:	2300      	movs	r3, #0
    8398:	9a01      	ldr	r2, [sp, #4]
    839a:	7013      	strb	r3, [r2, #0]
			cpu_irq_prev_interrupt_state = true;
    839c:	2201      	movs	r2, #1
    839e:	4b07      	ldr	r3, [pc, #28]	; (83bc <cpu_irq_enter_critical+0x60>)
    83a0:	447b      	add	r3, pc
    83a2:	701a      	strb	r2, [r3, #0]
    83a4:	e7ea      	b.n	837c <cpu_irq_enter_critical+0x20>
    83a6:	46c0      	nop			; (mov r8, r8)
    83a8:	00001744 	.word	0x00001744
    83ac:	1fff7cc4 	.word	0x1fff7cc4
    83b0:	1fff7cb4 	.word	0x1fff7cb4
    83b4:	1fff7caa 	.word	0x1fff7caa
    83b8:	0000003c 	.word	0x0000003c
    83bc:	1fff7c8c 	.word	0x1fff7c8c

000083c0 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
    83c0:	b082      	sub	sp, #8
    83c2:	490d      	ldr	r1, [pc, #52]	; (83f8 <cpu_irq_leave_critical+0x38>)
    83c4:	4479      	add	r1, pc
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    83c6:	4b0d      	ldr	r3, [pc, #52]	; (83fc <cpu_irq_leave_critical+0x3c>)
    83c8:	447b      	add	r3, pc
    83ca:	681a      	ldr	r2, [r3, #0]
    83cc:	3a01      	subs	r2, #1
    83ce:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    83d0:	681b      	ldr	r3, [r3, #0]
    83d2:	2b00      	cmp	r3, #0
    83d4:	d10d      	bne.n	83f2 <cpu_irq_leave_critical+0x32>
    83d6:	4b0a      	ldr	r3, [pc, #40]	; (8400 <cpu_irq_leave_critical+0x40>)
    83d8:	447b      	add	r3, pc
    83da:	781b      	ldrb	r3, [r3, #0]
    83dc:	2b00      	cmp	r3, #0
    83de:	d008      	beq.n	83f2 <cpu_irq_leave_critical+0x32>
		cpu_irq_enable();
    83e0:	4b08      	ldr	r3, [pc, #32]	; (8404 <cpu_irq_leave_critical+0x44>)
    83e2:	58cb      	ldr	r3, [r1, r3]
    83e4:	9301      	str	r3, [sp, #4]
    83e6:	2301      	movs	r3, #1
    83e8:	9a01      	ldr	r2, [sp, #4]
    83ea:	7013      	strb	r3, [r2, #0]
    83ec:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    83f0:	b662      	cpsie	i
	}
}
    83f2:	b002      	add	sp, #8
    83f4:	4770      	bx	lr
    83f6:	46c0      	nop			; (mov r8, r8)
    83f8:	000016e0 	.word	0x000016e0
    83fc:	1fff7c60 	.word	0x1fff7c60
    8400:	1fff7c54 	.word	0x1fff7c54
    8404:	0000003c 	.word	0x0000003c

00008408 <DMAC_Handler>:
/**
 * \brief DMA interrupt service routine.
 *
 */
void DMAC_Handler( void )
{
    8408:	b530      	push	{r4, r5, lr}
    840a:	b083      	sub	sp, #12
    840c:	4c2b      	ldr	r4, [pc, #172]	; (84bc <DMAC_Handler+0xb4>)
    840e:	447c      	add	r4, pc
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    8410:	4b2b      	ldr	r3, [pc, #172]	; (84c0 <DMAC_Handler+0xb8>)
    8412:	58e3      	ldr	r3, [r4, r3]
    8414:	9301      	str	r3, [sp, #4]
    8416:	4798      	blx	r3
	uint32_t total_size;

	system_interrupt_enter_critical_section();

	/* Get Pending channel */
	active_channel =  DMAC->INTPEND.reg & DMAC_INTPEND_ID_Msk;
    8418:	492a      	ldr	r1, [pc, #168]	; (84c4 <DMAC_Handler+0xbc>)
    841a:	8c0b      	ldrh	r3, [r1, #32]
    841c:	220f      	movs	r2, #15

	Assert(_dma_active_resource[active_channel]);

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];
    841e:	4013      	ands	r3, r2
    8420:	009b      	lsls	r3, r3, #2
    8422:	4829      	ldr	r0, [pc, #164]	; (84c8 <DMAC_Handler+0xc0>)
    8424:	4478      	add	r0, pc
    8426:	5818      	ldr	r0, [r3, r0]

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    8428:	7803      	ldrb	r3, [r0, #0]
    842a:	401a      	ands	r2, r3
    842c:	233f      	movs	r3, #63	; 0x3f
    842e:	54ca      	strb	r2, [r1, r3]
	isr = DMAC->CHINTFLAG.reg;
    8430:	330f      	adds	r3, #15
    8432:	5cca      	ldrb	r2, [r1, r3]
    8434:	b2d2      	uxtb	r2, r2

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
    8436:	7803      	ldrb	r3, [r0, #0]
    8438:	4924      	ldr	r1, [pc, #144]	; (84cc <DMAC_Handler+0xc4>)
    843a:	5861      	ldr	r1, [r4, r1]
    843c:	9101      	str	r1, [sp, #4]
    843e:	011b      	lsls	r3, r3, #4
    8440:	18c9      	adds	r1, r1, r3
    8442:	8849      	ldrh	r1, [r1, #2]
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
    8444:	4d22      	ldr	r5, [pc, #136]	; (84d0 <DMAC_Handler+0xc8>)
    8446:	447d      	add	r5, pc
    8448:	18eb      	adds	r3, r5, r3
    844a:	885b      	ldrh	r3, [r3, #2]
	resource->transfered_size = total_size - write_size;
    844c:	1acb      	subs	r3, r1, r3
    844e:	6143      	str	r3, [r0, #20]

	/* DMA channel interrupt handler */
	if (isr & DMAC_CHINTENCLR_TERR) {
    8450:	07d3      	lsls	r3, r2, #31
    8452:	d512      	bpl.n	847a <DMAC_Handler+0x72>
		/* Clear transfer error flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TERR;
    8454:	2101      	movs	r1, #1
    8456:	234e      	movs	r3, #78	; 0x4e
    8458:	4a1a      	ldr	r2, [pc, #104]	; (84c4 <DMAC_Handler+0xbc>)
    845a:	54d1      	strb	r1, [r2, r3]

		/* Set I/O ERROR status */
		resource->job_status = STATUS_ERR_IO;
    845c:	3b3e      	subs	r3, #62	; 0x3e
    845e:	7443      	strb	r3, [r0, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1<<DMA_CALLBACK_TRANSFER_ERROR)) &&
    8460:	7c03      	ldrb	r3, [r0, #16]
    8462:	07db      	lsls	r3, r3, #31
    8464:	d503      	bpl.n	846e <DMAC_Handler+0x66>
				(resource->callback[DMA_CALLBACK_TRANSFER_ERROR])) {
    8466:	6843      	ldr	r3, [r0, #4]
		if ((resource->callback_enable & (1<<DMA_CALLBACK_TRANSFER_ERROR)) &&
    8468:	2b00      	cmp	r3, #0
    846a:	d000      	beq.n	846e <DMAC_Handler+0x66>
			resource->callback[DMA_CALLBACK_TRANSFER_ERROR](resource);
    846c:	4798      	blx	r3
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    846e:	4b19      	ldr	r3, [pc, #100]	; (84d4 <DMAC_Handler+0xcc>)
    8470:	58e3      	ldr	r3, [r4, r3]
    8472:	9301      	str	r3, [sp, #4]
    8474:	4798      	blx	r3
			resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND](resource);
		}
	}

	system_interrupt_leave_critical_section();
}
    8476:	b003      	add	sp, #12
    8478:	bd30      	pop	{r4, r5, pc}
	} else if (isr & DMAC_CHINTENCLR_TCMPL) {
    847a:	0793      	lsls	r3, r2, #30
    847c:	d50d      	bpl.n	849a <DMAC_Handler+0x92>
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TCMPL;
    847e:	2102      	movs	r1, #2
    8480:	234e      	movs	r3, #78	; 0x4e
    8482:	4a10      	ldr	r2, [pc, #64]	; (84c4 <DMAC_Handler+0xbc>)
    8484:	54d1      	strb	r1, [r2, r3]
		resource->job_status = STATUS_OK;
    8486:	2300      	movs	r3, #0
    8488:	7443      	strb	r3, [r0, #17]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
    848a:	7c03      	ldrb	r3, [r0, #16]
    848c:	079b      	lsls	r3, r3, #30
    848e:	d5ee      	bpl.n	846e <DMAC_Handler+0x66>
				(resource->callback[DMA_CALLBACK_TRANSFER_DONE])) {
    8490:	6883      	ldr	r3, [r0, #8]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
    8492:	2b00      	cmp	r3, #0
    8494:	d0eb      	beq.n	846e <DMAC_Handler+0x66>
			resource->callback[DMA_CALLBACK_TRANSFER_DONE](resource);
    8496:	4798      	blx	r3
    8498:	e7e9      	b.n	846e <DMAC_Handler+0x66>
	} else if (isr & DMAC_CHINTENCLR_SUSP) {
    849a:	0753      	lsls	r3, r2, #29
    849c:	d5e7      	bpl.n	846e <DMAC_Handler+0x66>
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_SUSP;
    849e:	2104      	movs	r1, #4
    84a0:	234e      	movs	r3, #78	; 0x4e
    84a2:	4a08      	ldr	r2, [pc, #32]	; (84c4 <DMAC_Handler+0xbc>)
    84a4:	54d1      	strb	r1, [r2, r3]
		resource->job_status = STATUS_SUSPEND;
    84a6:	3b48      	subs	r3, #72	; 0x48
    84a8:	7443      	strb	r3, [r0, #17]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
    84aa:	7c03      	ldrb	r3, [r0, #16]
    84ac:	075b      	lsls	r3, r3, #29
    84ae:	d5de      	bpl.n	846e <DMAC_Handler+0x66>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
    84b0:	68c3      	ldr	r3, [r0, #12]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
    84b2:	2b00      	cmp	r3, #0
    84b4:	d0db      	beq.n	846e <DMAC_Handler+0x66>
			resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND](resource);
    84b6:	4798      	blx	r3
    84b8:	e7d9      	b.n	846e <DMAC_Handler+0x66>
    84ba:	46c0      	nop			; (mov r8, r8)
    84bc:	00001696 	.word	0x00001696
    84c0:	00000034 	.word	0x00000034
    84c4:	41004800 	.word	0x41004800
    84c8:	1fff7c0c 	.word	0x1fff7c0c
    84cc:	0000000c 	.word	0x0000000c
    84d0:	1fff7c06 	.word	0x1fff7c06
    84d4:	00000000 	.word	0x00000000

000084d8 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    84d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    84da:	b083      	sub	sp, #12
    84dc:	4d16      	ldr	r5, [pc, #88]	; (8538 <EIC_Handler+0x60>)
    84de:	447d      	add	r5, pc
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    84e0:	4b16      	ldr	r3, [pc, #88]	; (853c <EIC_Handler+0x64>)
    84e2:	58eb      	ldr	r3, [r5, r3]
    84e4:	9301      	str	r3, [sp, #4]
    84e6:	2300      	movs	r3, #0
    84e8:	9a01      	ldr	r2, [sp, #4]
    84ea:	7013      	strb	r3, [r2, #0]

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    84ec:	4a14      	ldr	r2, [pc, #80]	; (8540 <EIC_Handler+0x68>)
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    84ee:	271f      	movs	r7, #31
    84f0:	2601      	movs	r6, #1
		return NULL;
    84f2:	2400      	movs	r4, #0
    84f4:	e00c      	b.n	8510 <EIC_Handler+0x38>
		return eics[eic_index];
    84f6:	4a12      	ldr	r2, [pc, #72]	; (8540 <EIC_Handler+0x68>)
    84f8:	e00a      	b.n	8510 <EIC_Handler+0x38>
    84fa:	4b10      	ldr	r3, [pc, #64]	; (853c <EIC_Handler+0x64>)
    84fc:	58ea      	ldr	r2, [r5, r3]
    84fe:	7813      	ldrb	r3, [r2, #0]
    8500:	3301      	adds	r3, #1
    8502:	b2db      	uxtb	r3, r3
    8504:	7013      	strb	r3, [r2, #0]
    8506:	2b0f      	cmp	r3, #15
    8508:	d814      	bhi.n	8534 <EIC_Handler+0x5c>
		return NULL;
    850a:	0022      	movs	r2, r4
	if (eic_index < EIC_INST_NUM) {
    850c:	2b1f      	cmp	r3, #31
    850e:	d9f2      	bls.n	84f6 <EIC_Handler+0x1e>
	uint32_t eic_mask   = (1UL << (channel % 32));
    8510:	0039      	movs	r1, r7
    8512:	4019      	ands	r1, r3
    8514:	0030      	movs	r0, r6
    8516:	4088      	lsls	r0, r1
    8518:	0001      	movs	r1, r0

	return (eic_module->INTFLAG.reg & eic_mask);
    851a:	6910      	ldr	r0, [r2, #16]
		if (extint_chan_is_detected(_current_channel)) {
    851c:	4208      	tst	r0, r1
    851e:	d0ec      	beq.n	84fa <EIC_Handler+0x22>
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
    8520:	6111      	str	r1, [r2, #16]
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    8522:	4a08      	ldr	r2, [pc, #32]	; (8544 <EIC_Handler+0x6c>)
    8524:	58aa      	ldr	r2, [r5, r2]
    8526:	9201      	str	r2, [sp, #4]
    8528:	009b      	lsls	r3, r3, #2
    852a:	589b      	ldr	r3, [r3, r2]
    852c:	2b00      	cmp	r3, #0
    852e:	d0e4      	beq.n	84fa <EIC_Handler+0x22>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    8530:	4798      	blx	r3
    8532:	e7e2      	b.n	84fa <EIC_Handler+0x22>
			}
		}
	}
}
    8534:	b003      	add	sp, #12
    8536:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8538:	000015c6 	.word	0x000015c6
    853c:	00000064 	.word	0x00000064
    8540:	40001800 	.word	0x40001800
    8544:	00000054 	.word	0x00000054

00008548 <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    8548:	4a04      	ldr	r2, [pc, #16]	; (855c <_extint_enable+0x14>)
    854a:	7813      	ldrb	r3, [r2, #0]
    854c:	2102      	movs	r1, #2
    854e:	430b      	orrs	r3, r1
    8550:	7013      	strb	r3, [r2, #0]
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    8552:	7853      	ldrb	r3, [r2, #1]
    8554:	b25b      	sxtb	r3, r3
    8556:	2b00      	cmp	r3, #0
    8558:	dbfb      	blt.n	8552 <_extint_enable+0xa>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    855a:	4770      	bx	lr
    855c:	40001800 	.word	0x40001800

00008560 <_system_extint_init>:
{
    8560:	b510      	push	{r4, lr}
    8562:	b084      	sub	sp, #16
    8564:	4c16      	ldr	r4, [pc, #88]	; (85c0 <_system_extint_init+0x60>)
    8566:	447c      	add	r4, pc
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    8568:	4a16      	ldr	r2, [pc, #88]	; (85c4 <_system_extint_init+0x64>)
    856a:	6993      	ldr	r3, [r2, #24]
    856c:	2140      	movs	r1, #64	; 0x40
    856e:	430b      	orrs	r3, r1
    8570:	6193      	str	r3, [r2, #24]
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
    8572:	2302      	movs	r3, #2
    8574:	a903      	add	r1, sp, #12
    8576:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    8578:	2005      	movs	r0, #5
    857a:	4b13      	ldr	r3, [pc, #76]	; (85c8 <_system_extint_init+0x68>)
    857c:	58e3      	ldr	r3, [r4, r3]
    857e:	9301      	str	r3, [sp, #4]
    8580:	4798      	blx	r3
	system_gclk_chan_enable(EIC_GCLK_ID);
    8582:	2005      	movs	r0, #5
    8584:	4b11      	ldr	r3, [pc, #68]	; (85cc <_system_extint_init+0x6c>)
    8586:	58e3      	ldr	r3, [r4, r3]
    8588:	9301      	str	r3, [sp, #4]
    858a:	4798      	blx	r3
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    858c:	4a10      	ldr	r2, [pc, #64]	; (85d0 <_system_extint_init+0x70>)
    858e:	7813      	ldrb	r3, [r2, #0]
    8590:	2101      	movs	r1, #1
    8592:	430b      	orrs	r3, r1
    8594:	7013      	strb	r3, [r2, #0]
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    8596:	7853      	ldrb	r3, [r2, #1]
    8598:	b25b      	sxtb	r3, r3
    859a:	2b00      	cmp	r3, #0
    859c:	dbfb      	blt.n	8596 <_system_extint_init+0x36>
    859e:	4b0d      	ldr	r3, [pc, #52]	; (85d4 <_system_extint_init+0x74>)
    85a0:	58e3      	ldr	r3, [r4, r3]
    85a2:	0019      	movs	r1, r3
    85a4:	3140      	adds	r1, #64	; 0x40
		_extint_dev.callbacks[j] = NULL;
    85a6:	2200      	movs	r2, #0
    85a8:	c304      	stmia	r3!, {r2}
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    85aa:	4299      	cmp	r1, r3
    85ac:	d1fc      	bne.n	85a8 <_system_extint_init+0x48>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    85ae:	2210      	movs	r2, #16
    85b0:	4b09      	ldr	r3, [pc, #36]	; (85d8 <_system_extint_init+0x78>)
    85b2:	601a      	str	r2, [r3, #0]
	_extint_enable();
    85b4:	4b09      	ldr	r3, [pc, #36]	; (85dc <_system_extint_init+0x7c>)
    85b6:	447b      	add	r3, pc
    85b8:	4798      	blx	r3
}
    85ba:	b004      	add	sp, #16
    85bc:	bd10      	pop	{r4, pc}
    85be:	46c0      	nop			; (mov r8, r8)
    85c0:	0000153e 	.word	0x0000153e
    85c4:	40000400 	.word	0x40000400
    85c8:	0000002c 	.word	0x0000002c
    85cc:	00000078 	.word	0x00000078
    85d0:	40001800 	.word	0x40001800
    85d4:	00000054 	.word	0x00000054
    85d8:	e000e100 	.word	0xe000e100
    85dc:	ffffff8f 	.word	0xffffff8f

000085e0 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    85e0:	b510      	push	{r4, lr}
    85e2:	b084      	sub	sp, #16
    85e4:	4a08      	ldr	r2, [pc, #32]	; (8608 <port_pin_set_config+0x28>)
    85e6:	447a      	add	r2, pc
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    85e8:	2480      	movs	r4, #128	; 0x80
    85ea:	ab03      	add	r3, sp, #12
    85ec:	701c      	strb	r4, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    85ee:	780c      	ldrb	r4, [r1, #0]
    85f0:	705c      	strb	r4, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    85f2:	784c      	ldrb	r4, [r1, #1]
    85f4:	709c      	strb	r4, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    85f6:	7889      	ldrb	r1, [r1, #2]
    85f8:	70d9      	strb	r1, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    85fa:	0019      	movs	r1, r3
    85fc:	4b03      	ldr	r3, [pc, #12]	; (860c <port_pin_set_config+0x2c>)
    85fe:	58d3      	ldr	r3, [r2, r3]
    8600:	9301      	str	r3, [sp, #4]
    8602:	4798      	blx	r3
}
    8604:	b004      	add	sp, #16
    8606:	bd10      	pop	{r4, pc}
    8608:	000014be 	.word	0x000014be
    860c:	000000a4 	.word	0x000000a4

00008610 <RTC_Handler>:
/**
 * \internal ISR handler for RTC
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
    8610:	b510      	push	{r4, lr}
    8612:	4b10      	ldr	r3, [pc, #64]	; (8654 <RTC_Handler+0x44>)
    8614:	447b      	add	r3, pc
	struct rtc_module *module = _rtc_instance[instance_index];
    8616:	4a10      	ldr	r2, [pc, #64]	; (8658 <RTC_Handler+0x48>)
    8618:	589b      	ldr	r3, [r3, r2]
    861a:	681a      	ldr	r2, [r3, #0]
	Rtc *const rtc_module = module->hw;
    861c:	6814      	ldr	r4, [r2, #0]
	uint16_t callback_mask = module->enabled_callback;
    861e:	8a51      	ldrh	r1, [r2, #18]
	callback_mask &= module->registered_callback;
    8620:	8a13      	ldrh	r3, [r2, #16]
    8622:	4019      	ands	r1, r3
	uint16_t interrupt_status = rtc_module->MODE2.INTFLAG.reg;
    8624:	7a20      	ldrb	r0, [r4, #8]
	interrupt_status &= rtc_module->MODE2.INTENSET.reg;
    8626:	79e3      	ldrb	r3, [r4, #7]
    8628:	4003      	ands	r3, r0
	if (interrupt_status & RTC_MODE2_INTFLAG_OVF) {
    862a:	b258      	sxtb	r0, r3
    862c:	2800      	cmp	r0, #0
    862e:	db06      	blt.n	863e <RTC_Handler+0x2e>
	} else if (interrupt_status & RTC_MODE2_INTFLAG_ALARM(1 << 0)) {
    8630:	07db      	lsls	r3, r3, #31
    8632:	d503      	bpl.n	863c <RTC_Handler+0x2c>
		if (callback_mask & (1 << RTC_CALENDAR_CALLBACK_ALARM_0)) {
    8634:	07cb      	lsls	r3, r1, #31
    8636:	d40a      	bmi.n	864e <RTC_Handler+0x3e>
		rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_ALARM(1 << 0);
    8638:	2301      	movs	r3, #1
    863a:	7223      	strb	r3, [r4, #8]
	_rtc_interrupt_handler(0);
}
    863c:	bd10      	pop	{r4, pc}
		if (callback_mask & (1 << RTC_CALENDAR_CALLBACK_OVERFLOW)) {
    863e:	078b      	lsls	r3, r1, #30
    8640:	d402      	bmi.n	8648 <RTC_Handler+0x38>
		rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_OVF;
    8642:	2380      	movs	r3, #128	; 0x80
    8644:	7223      	strb	r3, [r4, #8]
    8646:	e7f9      	b.n	863c <RTC_Handler+0x2c>
			module->callbacks[RTC_CALENDAR_CALLBACK_OVERFLOW]();
    8648:	68d3      	ldr	r3, [r2, #12]
    864a:	4798      	blx	r3
    864c:	e7f9      	b.n	8642 <RTC_Handler+0x32>
			module->callbacks[RTC_CALENDAR_CALLBACK_ALARM_0]();
    864e:	6893      	ldr	r3, [r2, #8]
    8650:	4798      	blx	r3
    8652:	e7f1      	b.n	8638 <RTC_Handler+0x28>
    8654:	00001490 	.word	0x00001490
    8658:	00000004 	.word	0x00000004

0000865c <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    865c:	b510      	push	{r4, lr}
    865e:	4b03      	ldr	r3, [pc, #12]	; (866c <SERCOM0_Handler+0x10>)
    8660:	447b      	add	r3, pc
    8662:	681b      	ldr	r3, [r3, #0]
    8664:	2000      	movs	r0, #0
    8666:	4798      	blx	r3
    8668:	bd10      	pop	{r4, pc}
    866a:	46c0      	nop			; (mov r8, r8)
    866c:	1fff7a3c 	.word	0x1fff7a3c

00008670 <SERCOM1_Handler>:
    8670:	b510      	push	{r4, lr}
    8672:	4b03      	ldr	r3, [pc, #12]	; (8680 <SERCOM1_Handler+0x10>)
    8674:	447b      	add	r3, pc
    8676:	685b      	ldr	r3, [r3, #4]
    8678:	2001      	movs	r0, #1
    867a:	4798      	blx	r3
    867c:	bd10      	pop	{r4, pc}
    867e:	46c0      	nop			; (mov r8, r8)
    8680:	1fff7a28 	.word	0x1fff7a28

00008684 <SERCOM2_Handler>:
    8684:	b510      	push	{r4, lr}
    8686:	4b03      	ldr	r3, [pc, #12]	; (8694 <SERCOM2_Handler+0x10>)
    8688:	447b      	add	r3, pc
    868a:	689b      	ldr	r3, [r3, #8]
    868c:	2002      	movs	r0, #2
    868e:	4798      	blx	r3
    8690:	bd10      	pop	{r4, pc}
    8692:	46c0      	nop			; (mov r8, r8)
    8694:	1fff7a14 	.word	0x1fff7a14

00008698 <SERCOM3_Handler>:
    8698:	b510      	push	{r4, lr}
    869a:	4b03      	ldr	r3, [pc, #12]	; (86a8 <SERCOM3_Handler+0x10>)
    869c:	447b      	add	r3, pc
    869e:	68db      	ldr	r3, [r3, #12]
    86a0:	2003      	movs	r0, #3
    86a2:	4798      	blx	r3
    86a4:	bd10      	pop	{r4, pc}
    86a6:	46c0      	nop			; (mov r8, r8)
    86a8:	1fff7a00 	.word	0x1fff7a00

000086ac <SERCOM4_Handler>:
    86ac:	b510      	push	{r4, lr}
    86ae:	4b03      	ldr	r3, [pc, #12]	; (86bc <SERCOM4_Handler+0x10>)
    86b0:	447b      	add	r3, pc
    86b2:	691b      	ldr	r3, [r3, #16]
    86b4:	2004      	movs	r0, #4
    86b6:	4798      	blx	r3
    86b8:	bd10      	pop	{r4, pc}
    86ba:	46c0      	nop			; (mov r8, r8)
    86bc:	1fff79ec 	.word	0x1fff79ec

000086c0 <SERCOM5_Handler>:
    86c0:	b510      	push	{r4, lr}
    86c2:	4b03      	ldr	r3, [pc, #12]	; (86d0 <SERCOM5_Handler+0x10>)
    86c4:	447b      	add	r3, pc
    86c6:	695b      	ldr	r3, [r3, #20]
    86c8:	2005      	movs	r0, #5
    86ca:	4798      	blx	r3
    86cc:	bd10      	pop	{r4, pc}
    86ce:	46c0      	nop			; (mov r8, r8)
    86d0:	1fff79d8 	.word	0x1fff79d8

000086d4 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    86d4:	b500      	push	{lr}
    86d6:	b083      	sub	sp, #12
    86d8:	4b23      	ldr	r3, [pc, #140]	; (8768 <system_clock_source_get_hz+0x94>)
    86da:	447b      	add	r3, pc
	switch (clock_source) {
    86dc:	2808      	cmp	r0, #8
    86de:	d806      	bhi.n	86ee <system_clock_source_get_hz+0x1a>
    86e0:	f001 f8f0 	bl	98c4 <__gnu_thumb1_case_uqi>
    86e4:	3e050507 	.word	0x3e050507
    86e8:	160b123e 	.word	0x160b123e
    86ec:	34          	.byte	0x34
    86ed:	00          	.byte	0x00

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
    86ee:	2000      	movs	r0, #0
    86f0:	e038      	b.n	8764 <system_clock_source_get_hz+0x90>
		return _system_clock_inst.xosc.frequency;
    86f2:	4b1e      	ldr	r3, [pc, #120]	; (876c <system_clock_source_get_hz+0x98>)
    86f4:	447b      	add	r3, pc
    86f6:	6918      	ldr	r0, [r3, #16]
    86f8:	e034      	b.n	8764 <system_clock_source_get_hz+0x90>
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    86fa:	4b1d      	ldr	r3, [pc, #116]	; (8770 <system_clock_source_get_hz+0x9c>)
    86fc:	6a1b      	ldr	r3, [r3, #32]
    86fe:	059b      	lsls	r3, r3, #22
    8700:	0f9b      	lsrs	r3, r3, #30
    8702:	481c      	ldr	r0, [pc, #112]	; (8774 <system_clock_source_get_hz+0xa0>)
    8704:	40d8      	lsrs	r0, r3
    8706:	e02d      	b.n	8764 <system_clock_source_get_hz+0x90>
		return _system_clock_inst.xosc32k.frequency;
    8708:	4b1b      	ldr	r3, [pc, #108]	; (8778 <system_clock_source_get_hz+0xa4>)
    870a:	447b      	add	r3, pc
    870c:	6958      	ldr	r0, [r3, #20]
    870e:	e029      	b.n	8764 <system_clock_source_get_hz+0x90>
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    8710:	4a1a      	ldr	r2, [pc, #104]	; (877c <system_clock_source_get_hz+0xa8>)
    8712:	447a      	add	r2, pc
    8714:	6812      	ldr	r2, [r2, #0]
			return 0;
    8716:	2000      	movs	r0, #0
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    8718:	0792      	lsls	r2, r2, #30
    871a:	d523      	bpl.n	8764 <system_clock_source_get_hz+0x90>
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    871c:	4814      	ldr	r0, [pc, #80]	; (8770 <system_clock_source_get_hz+0x9c>)
    871e:	2110      	movs	r1, #16
    8720:	68c2      	ldr	r2, [r0, #12]
    8722:	4211      	tst	r1, r2
    8724:	d0fc      	beq.n	8720 <system_clock_source_get_hz+0x4c>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    8726:	4a16      	ldr	r2, [pc, #88]	; (8780 <system_clock_source_get_hz+0xac>)
    8728:	447a      	add	r2, pc
    872a:	6812      	ldr	r2, [r2, #0]
    872c:	0752      	lsls	r2, r2, #29
    872e:	d401      	bmi.n	8734 <system_clock_source_get_hz+0x60>
		return 48000000UL;
    8730:	4814      	ldr	r0, [pc, #80]	; (8784 <system_clock_source_get_hz+0xb0>)
    8732:	e017      	b.n	8764 <system_clock_source_get_hz+0x90>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    8734:	2000      	movs	r0, #0
    8736:	4a14      	ldr	r2, [pc, #80]	; (8788 <system_clock_source_get_hz+0xb4>)
    8738:	589b      	ldr	r3, [r3, r2]
    873a:	9301      	str	r3, [sp, #4]
    873c:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    873e:	4b13      	ldr	r3, [pc, #76]	; (878c <system_clock_source_get_hz+0xb8>)
    8740:	447b      	add	r3, pc
    8742:	689b      	ldr	r3, [r3, #8]
    8744:	041b      	lsls	r3, r3, #16
    8746:	0c1b      	lsrs	r3, r3, #16
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    8748:	4358      	muls	r0, r3
    874a:	e00b      	b.n	8764 <system_clock_source_get_hz+0x90>
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    874c:	2350      	movs	r3, #80	; 0x50
    874e:	4a08      	ldr	r2, [pc, #32]	; (8770 <system_clock_source_get_hz+0x9c>)
    8750:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    8752:	2000      	movs	r0, #0
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    8754:	075b      	lsls	r3, r3, #29
    8756:	d505      	bpl.n	8764 <system_clock_source_get_hz+0x90>
		return _system_clock_inst.dpll.frequency;
    8758:	4b0d      	ldr	r3, [pc, #52]	; (8790 <system_clock_source_get_hz+0xbc>)
    875a:	447b      	add	r3, pc
    875c:	68d8      	ldr	r0, [r3, #12]
    875e:	e001      	b.n	8764 <system_clock_source_get_hz+0x90>
		return 32768UL;
    8760:	2080      	movs	r0, #128	; 0x80
    8762:	0200      	lsls	r0, r0, #8
	}
}
    8764:	b003      	add	sp, #12
    8766:	bd00      	pop	{pc}
    8768:	000013ca 	.word	0x000013ca
    876c:	1fff79c0 	.word	0x1fff79c0
    8770:	40000800 	.word	0x40000800
    8774:	007a1200 	.word	0x007a1200
    8778:	1fff79aa 	.word	0x1fff79aa
    877c:	1fff79a2 	.word	0x1fff79a2
    8780:	1fff798c 	.word	0x1fff798c
    8784:	02dc6c00 	.word	0x02dc6c00
    8788:	00000058 	.word	0x00000058
    878c:	1fff7974 	.word	0x1fff7974
    8790:	1fff795a 	.word	0x1fff795a

00008794 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    8794:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    8796:	490c      	ldr	r1, [pc, #48]	; (87c8 <system_clock_source_osc8m_set_config+0x34>)
    8798:	6a0b      	ldr	r3, [r1, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    879a:	7804      	ldrb	r4, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    879c:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    879e:	7840      	ldrb	r0, [r0, #1]
    87a0:	2201      	movs	r2, #1
    87a2:	4010      	ands	r0, r2
    87a4:	0180      	lsls	r0, r0, #6
    87a6:	2640      	movs	r6, #64	; 0x40
    87a8:	43b3      	bics	r3, r6
    87aa:	4303      	orrs	r3, r0
    87ac:	402a      	ands	r2, r5
    87ae:	01d2      	lsls	r2, r2, #7
    87b0:	2080      	movs	r0, #128	; 0x80
    87b2:	4383      	bics	r3, r0
    87b4:	4313      	orrs	r3, r2
    87b6:	2203      	movs	r2, #3
    87b8:	4022      	ands	r2, r4
    87ba:	0212      	lsls	r2, r2, #8
    87bc:	4803      	ldr	r0, [pc, #12]	; (87cc <system_clock_source_osc8m_set_config+0x38>)
    87be:	4003      	ands	r3, r0
    87c0:	4313      	orrs	r3, r2
    87c2:	620b      	str	r3, [r1, #32]
}
    87c4:	bd70      	pop	{r4, r5, r6, pc}
    87c6:	46c0      	nop			; (mov r8, r8)
    87c8:	40000800 	.word	0x40000800
    87cc:	fffffcff 	.word	0xfffffcff

000087d0 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    87d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    87d2:	46de      	mov	lr, fp
    87d4:	4657      	mov	r7, sl
    87d6:	464e      	mov	r6, r9
    87d8:	4645      	mov	r5, r8
    87da:	b5e0      	push	{r5, r6, r7, lr}
    87dc:	0001      	movs	r1, r0
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    87de:	4b27      	ldr	r3, [pc, #156]	; (887c <system_clock_source_xosc32k_set_config+0xac>)
    87e0:	469b      	mov	fp, r3
    87e2:	8a9b      	ldrh	r3, [r3, #20]

	temp.bit.STARTUP = config->startup_time;
    87e4:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    87e6:	7800      	ldrb	r0, [r0, #0]
    87e8:	4242      	negs	r2, r0
    87ea:	4142      	adcs	r2, r0
    87ec:	4691      	mov	r9, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    87ee:	7888      	ldrb	r0, [r1, #2]
	temp.bit.EN1K = config->enable_1khz_output;
    87f0:	78ca      	ldrb	r2, [r1, #3]
    87f2:	4694      	mov	ip, r2
	temp.bit.EN32K = config->enable_32khz_output;
    87f4:	790a      	ldrb	r2, [r1, #4]
    87f6:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
    87f8:	7b4e      	ldrb	r6, [r1, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    87fa:	7b0f      	ldrb	r7, [r1, #12]
	temp.bit.WRTLOCK  = config->write_once;
    87fc:	7b8c      	ldrb	r4, [r1, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    87fe:	688a      	ldr	r2, [r1, #8]
    8800:	491f      	ldr	r1, [pc, #124]	; (8880 <system_clock_source_xosc32k_set_config+0xb0>)
    8802:	4479      	add	r1, pc
    8804:	614a      	str	r2, [r1, #20]

	SYSCTRL->XOSC32K = temp;
    8806:	2101      	movs	r1, #1
    8808:	464a      	mov	r2, r9
    880a:	0092      	lsls	r2, r2, #2
    880c:	4691      	mov	r9, r2
    880e:	2204      	movs	r2, #4
    8810:	4393      	bics	r3, r2
    8812:	464a      	mov	r2, r9
    8814:	4313      	orrs	r3, r2
    8816:	4642      	mov	r2, r8
    8818:	400a      	ands	r2, r1
    881a:	00d2      	lsls	r2, r2, #3
    881c:	4690      	mov	r8, r2
    881e:	2208      	movs	r2, #8
    8820:	4393      	bics	r3, r2
    8822:	4642      	mov	r2, r8
    8824:	4313      	orrs	r3, r2
    8826:	4662      	mov	r2, ip
    8828:	400a      	ands	r2, r1
    882a:	0112      	lsls	r2, r2, #4
    882c:	4694      	mov	ip, r2
    882e:	2210      	movs	r2, #16
    8830:	4393      	bics	r3, r2
    8832:	4662      	mov	r2, ip
    8834:	4313      	orrs	r3, r2
    8836:	4008      	ands	r0, r1
    8838:	0140      	lsls	r0, r0, #5
    883a:	2220      	movs	r2, #32
    883c:	4393      	bics	r3, r2
    883e:	4303      	orrs	r3, r0
    8840:	400f      	ands	r7, r1
    8842:	01bf      	lsls	r7, r7, #6
    8844:	2040      	movs	r0, #64	; 0x40
    8846:	4383      	bics	r3, r0
    8848:	433b      	orrs	r3, r7
    884a:	400e      	ands	r6, r1
    884c:	01f6      	lsls	r6, r6, #7
    884e:	3040      	adds	r0, #64	; 0x40
    8850:	4383      	bics	r3, r0
    8852:	4333      	orrs	r3, r6
    8854:	3879      	subs	r0, #121	; 0x79
    8856:	4005      	ands	r5, r0
    8858:	022d      	lsls	r5, r5, #8
    885a:	480a      	ldr	r0, [pc, #40]	; (8884 <system_clock_source_xosc32k_set_config+0xb4>)
    885c:	4003      	ands	r3, r0
    885e:	432b      	orrs	r3, r5
    8860:	4021      	ands	r1, r4
    8862:	0309      	lsls	r1, r1, #12
    8864:	4808      	ldr	r0, [pc, #32]	; (8888 <system_clock_source_xosc32k_set_config+0xb8>)
    8866:	4003      	ands	r3, r0
    8868:	430b      	orrs	r3, r1
    886a:	465a      	mov	r2, fp
    886c:	8293      	strh	r3, [r2, #20]
}
    886e:	bc3c      	pop	{r2, r3, r4, r5}
    8870:	4690      	mov	r8, r2
    8872:	4699      	mov	r9, r3
    8874:	46a2      	mov	sl, r4
    8876:	46ab      	mov	fp, r5
    8878:	bdf0      	pop	{r4, r5, r6, r7, pc}
    887a:	46c0      	nop			; (mov r8, r8)
    887c:	40000800 	.word	0x40000800
    8880:	1fff78b2 	.word	0x1fff78b2
    8884:	fffff8ff 	.word	0xfffff8ff
    8888:	ffffefff 	.word	0xffffefff

0000888c <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    888c:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    888e:	7a03      	ldrb	r3, [r0, #8]
    8890:	069b      	lsls	r3, r3, #26
    8892:	0c1b      	lsrs	r3, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    8894:	8942      	ldrh	r2, [r0, #10]
    8896:	0592      	lsls	r2, r2, #22
    8898:	0d92      	lsrs	r2, r2, #22
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    889a:	4313      	orrs	r3, r2
	_system_clock_inst.dfll.val =
    889c:	491a      	ldr	r1, [pc, #104]	; (8908 <system_clock_source_dfll_set_config+0x7c>)
    889e:	4479      	add	r1, pc
    88a0:	604b      	str	r3, [r1, #4]

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    88a2:	7983      	ldrb	r3, [r0, #6]
    88a4:	79c2      	ldrb	r2, [r0, #7]
    88a6:	4313      	orrs	r3, r2
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    88a8:	8842      	ldrh	r2, [r0, #2]
    88aa:	8884      	ldrh	r4, [r0, #4]
    88ac:	4322      	orrs	r2, r4
    88ae:	4313      	orrs	r3, r2
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    88b0:	7842      	ldrb	r2, [r0, #1]
    88b2:	01d2      	lsls	r2, r2, #7
			(uint32_t)config->chill_cycle     |
    88b4:	4313      	orrs	r3, r2
	_system_clock_inst.dfll.control =
    88b6:	600b      	str	r3, [r1, #0]

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    88b8:	7803      	ldrb	r3, [r0, #0]
    88ba:	2b04      	cmp	r3, #4
    88bc:	d012      	beq.n	88e4 <system_clock_source_dfll_set_config+0x58>
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    88be:	2b20      	cmp	r3, #32
    88c0:	d10f      	bne.n	88e2 <system_clock_source_dfll_set_config+0x56>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    88c2:	7b03      	ldrb	r3, [r0, #12]
    88c4:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    88c6:	8a02      	ldrh	r2, [r0, #16]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    88c8:	4313      	orrs	r3, r2
    88ca:	89c2      	ldrh	r2, [r0, #14]
    88cc:	0412      	lsls	r2, r2, #16
    88ce:	490f      	ldr	r1, [pc, #60]	; (890c <system_clock_source_dfll_set_config+0x80>)
    88d0:	400a      	ands	r2, r1
    88d2:	4313      	orrs	r3, r2
		_system_clock_inst.dfll.mul =
    88d4:	4a0e      	ldr	r2, [pc, #56]	; (8910 <system_clock_source_dfll_set_config+0x84>)
    88d6:	447a      	add	r2, pc
    88d8:	6093      	str	r3, [r2, #8]

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    88da:	6811      	ldr	r1, [r2, #0]
    88dc:	4b0d      	ldr	r3, [pc, #52]	; (8914 <system_clock_source_dfll_set_config+0x88>)
    88de:	430b      	orrs	r3, r1
    88e0:	6013      	str	r3, [r2, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    88e2:	bd10      	pop	{r4, pc}
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    88e4:	7b03      	ldrb	r3, [r0, #12]
    88e6:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    88e8:	8a02      	ldrh	r2, [r0, #16]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    88ea:	4313      	orrs	r3, r2
    88ec:	89c2      	ldrh	r2, [r0, #14]
    88ee:	0412      	lsls	r2, r2, #16
    88f0:	4906      	ldr	r1, [pc, #24]	; (890c <system_clock_source_dfll_set_config+0x80>)
    88f2:	400a      	ands	r2, r1
    88f4:	4313      	orrs	r3, r2
		_system_clock_inst.dfll.mul =
    88f6:	4a08      	ldr	r2, [pc, #32]	; (8918 <system_clock_source_dfll_set_config+0x8c>)
    88f8:	447a      	add	r2, pc
    88fa:	6093      	str	r3, [r2, #8]
		_system_clock_inst.dfll.control |= config->loop_mode;
    88fc:	6813      	ldr	r3, [r2, #0]
    88fe:	2104      	movs	r1, #4
    8900:	430b      	orrs	r3, r1
    8902:	6013      	str	r3, [r2, #0]
    8904:	e7ed      	b.n	88e2 <system_clock_source_dfll_set_config+0x56>
    8906:	46c0      	nop			; (mov r8, r8)
    8908:	1fff7816 	.word	0x1fff7816
    890c:	03ff0000 	.word	0x03ff0000
    8910:	1fff77de 	.word	0x1fff77de
    8914:	00000424 	.word	0x00000424
    8918:	1fff77bc 	.word	0x1fff77bc

0000891c <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
    891c:	b500      	push	{lr}
	switch (clock_source) {
    891e:	2808      	cmp	r0, #8
    8920:	d806      	bhi.n	8930 <system_clock_source_enable+0x14>
    8922:	f000 ffcf 	bl	98c4 <__gnu_thumb1_case_uqi>
    8926:	0515      	.short	0x0515
    8928:	1c0e4e05 	.word	0x1c0e4e05
    892c:	2307      	.short	0x2307
    892e:	46          	.byte	0x46
    892f:	00          	.byte	0x00
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    8930:	2017      	movs	r0, #23
    8932:	e047      	b.n	89c4 <system_clock_source_enable+0xa8>
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    8934:	4a24      	ldr	r2, [pc, #144]	; (89c8 <system_clock_source_enable+0xac>)
    8936:	6a13      	ldr	r3, [r2, #32]
    8938:	2102      	movs	r1, #2
    893a:	430b      	orrs	r3, r1
    893c:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    893e:	2000      	movs	r0, #0
    8940:	e040      	b.n	89c4 <system_clock_source_enable+0xa8>
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    8942:	4a21      	ldr	r2, [pc, #132]	; (89c8 <system_clock_source_enable+0xac>)
    8944:	6993      	ldr	r3, [r2, #24]
    8946:	2102      	movs	r1, #2
    8948:	430b      	orrs	r3, r1
    894a:	6193      	str	r3, [r2, #24]
	}

	return STATUS_OK;
    894c:	2000      	movs	r0, #0
		break;
    894e:	e039      	b.n	89c4 <system_clock_source_enable+0xa8>
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    8950:	4a1d      	ldr	r2, [pc, #116]	; (89c8 <system_clock_source_enable+0xac>)
    8952:	8a13      	ldrh	r3, [r2, #16]
    8954:	2102      	movs	r1, #2
    8956:	430b      	orrs	r3, r1
    8958:	8213      	strh	r3, [r2, #16]
	return STATUS_OK;
    895a:	2000      	movs	r0, #0
		break;
    895c:	e032      	b.n	89c4 <system_clock_source_enable+0xa8>
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    895e:	4a1a      	ldr	r2, [pc, #104]	; (89c8 <system_clock_source_enable+0xac>)
    8960:	8a93      	ldrh	r3, [r2, #20]
    8962:	2102      	movs	r1, #2
    8964:	430b      	orrs	r3, r1
    8966:	8293      	strh	r3, [r2, #20]
	return STATUS_OK;
    8968:	2000      	movs	r0, #0
		break;
    896a:	e02b      	b.n	89c4 <system_clock_source_enable+0xa8>
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    896c:	4917      	ldr	r1, [pc, #92]	; (89cc <system_clock_source_enable+0xb0>)
    896e:	4479      	add	r1, pc
    8970:	680b      	ldr	r3, [r1, #0]
    8972:	2202      	movs	r2, #2
    8974:	4313      	orrs	r3, r2
    8976:	600b      	str	r3, [r1, #0]
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    8978:	4b13      	ldr	r3, [pc, #76]	; (89c8 <system_clock_source_enable+0xac>)
    897a:	849a      	strh	r2, [r3, #36]	; 0x24
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    897c:	0019      	movs	r1, r3
    897e:	320e      	adds	r2, #14
    8980:	68cb      	ldr	r3, [r1, #12]
    8982:	421a      	tst	r2, r3
    8984:	d0fc      	beq.n	8980 <system_clock_source_enable+0x64>
	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    8986:	4a12      	ldr	r2, [pc, #72]	; (89d0 <system_clock_source_enable+0xb4>)
    8988:	447a      	add	r2, pc
    898a:	6891      	ldr	r1, [r2, #8]
    898c:	4b0e      	ldr	r3, [pc, #56]	; (89c8 <system_clock_source_enable+0xac>)
    898e:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    8990:	6852      	ldr	r2, [r2, #4]
    8992:	629a      	str	r2, [r3, #40]	; 0x28
	SYSCTRL->DFLLCTRL.reg = 0;
    8994:	2200      	movs	r2, #0
    8996:	849a      	strh	r2, [r3, #36]	; 0x24
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    8998:	0019      	movs	r1, r3
    899a:	3210      	adds	r2, #16
    899c:	68cb      	ldr	r3, [r1, #12]
    899e:	421a      	tst	r2, r3
    89a0:	d0fc      	beq.n	899c <system_clock_source_enable+0x80>
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    89a2:	4b0c      	ldr	r3, [pc, #48]	; (89d4 <system_clock_source_enable+0xb8>)
    89a4:	447b      	add	r3, pc
    89a6:	681b      	ldr	r3, [r3, #0]
    89a8:	b29b      	uxth	r3, r3
    89aa:	4a07      	ldr	r2, [pc, #28]	; (89c8 <system_clock_source_enable+0xac>)
    89ac:	8493      	strh	r3, [r2, #36]	; 0x24
	return STATUS_OK;
    89ae:	2000      	movs	r0, #0
    89b0:	e008      	b.n	89c4 <system_clock_source_enable+0xa8>
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    89b2:	4905      	ldr	r1, [pc, #20]	; (89c8 <system_clock_source_enable+0xac>)
    89b4:	2244      	movs	r2, #68	; 0x44
    89b6:	5c8b      	ldrb	r3, [r1, r2]
    89b8:	2002      	movs	r0, #2
    89ba:	4303      	orrs	r3, r0
    89bc:	548b      	strb	r3, [r1, r2]
	return STATUS_OK;
    89be:	2000      	movs	r0, #0
		break;
    89c0:	e000      	b.n	89c4 <system_clock_source_enable+0xa8>
		return STATUS_OK;
    89c2:	2000      	movs	r0, #0
}
    89c4:	bd00      	pop	{pc}
    89c6:	46c0      	nop			; (mov r8, r8)
    89c8:	40000800 	.word	0x40000800
    89cc:	1fff7746 	.word	0x1fff7746
    89d0:	1fff772c 	.word	0x1fff772c
    89d4:	1fff7710 	.word	0x1fff7710

000089d8 <system_clock_source_is_ready>:
 * \retval true   Clock source is enabled and ready
 * \retval false  Clock source is disabled or not yet ready
 */
bool system_clock_source_is_ready(
		const enum system_clock_source clock_source)
{
    89d8:	b500      	push	{lr}
	uint32_t mask = 0;

	switch (clock_source) {
    89da:	2808      	cmp	r0, #8
    89dc:	d808      	bhi.n	89f0 <system_clock_source_is_ready+0x18>
    89de:	f000 ff71 	bl	98c4 <__gnu_thumb1_case_uqi>
    89e2:	0719      	.short	0x0719
    89e4:	09052207 	.word	0x09052207
    89e8:	0b17      	.short	0x0b17
    89ea:	0d          	.byte	0x0d
    89eb:	00          	.byte	0x00
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		mask = SYSCTRL_PCLKSR_OSC8MRDY;
		break;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		mask = SYSCTRL_PCLKSR_OSC32KRDY;
    89ec:	2304      	movs	r3, #4
    89ee:	e012      	b.n	8a16 <system_clock_source_is_ready+0x3e>
	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */
		return true;

	default:
		return false;
    89f0:	2000      	movs	r0, #0
    89f2:	e017      	b.n	8a24 <system_clock_source_is_ready+0x4c>
		mask = SYSCTRL_PCLKSR_XOSC32KRDY;
    89f4:	2302      	movs	r3, #2
		break;
    89f6:	e00e      	b.n	8a16 <system_clock_source_is_ready+0x3e>
			mask = (SYSCTRL_PCLKSR_DFLLRDY |
    89f8:	23d0      	movs	r3, #208	; 0xd0
		break;
    89fa:	e00c      	b.n	8a16 <system_clock_source_is_ready+0x3e>
		return ((SYSCTRL->DPLLSTATUS.reg &
    89fc:	2350      	movs	r3, #80	; 0x50
    89fe:	4a0b      	ldr	r2, [pc, #44]	; (8a2c <system_clock_source_is_ready+0x54>)
    8a00:	5cd0      	ldrb	r0, [r2, r3]
				(SYSCTRL_DPLLSTATUS_CLKRDY | SYSCTRL_DPLLSTATUS_LOCK)) ==
    8a02:	3b4d      	subs	r3, #77	; 0x4d
    8a04:	4018      	ands	r0, r3
    8a06:	3803      	subs	r0, #3
    8a08:	4243      	negs	r3, r0
    8a0a:	4158      	adcs	r0, r3
    8a0c:	b2c0      	uxtb	r0, r0
    8a0e:	e009      	b.n	8a24 <system_clock_source_is_ready+0x4c>
		mask = SYSCTRL_PCLKSR_OSC8MRDY;
    8a10:	2308      	movs	r3, #8
    8a12:	e000      	b.n	8a16 <system_clock_source_is_ready+0x3e>
		mask = SYSCTRL_PCLKSR_XOSCRDY;
    8a14:	2301      	movs	r3, #1
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    8a16:	4a05      	ldr	r2, [pc, #20]	; (8a2c <system_clock_source_is_ready+0x54>)
    8a18:	68d0      	ldr	r0, [r2, #12]
    8a1a:	4018      	ands	r0, r3
    8a1c:	1ac0      	subs	r0, r0, r3
    8a1e:	4243      	negs	r3, r0
    8a20:	4158      	adcs	r0, r3
    8a22:	b2c0      	uxtb	r0, r0
}
    8a24:	bd00      	pop	{pc}
		return true;
    8a26:	2001      	movs	r0, #1
    8a28:	e7fc      	b.n	8a24 <system_clock_source_is_ready+0x4c>
    8a2a:	46c0      	nop			; (mov r8, r8)
    8a2c:	40000800 	.word	0x40000800

00008a30 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    8a30:	b5f0      	push	{r4, r5, r6, r7, lr}
    8a32:	46c6      	mov	lr, r8
    8a34:	b500      	push	{lr}
    8a36:	b092      	sub	sp, #72	; 0x48
    8a38:	4f63      	ldr	r7, [pc, #396]	; (8bc8 <system_clock_init+0x198>)
    8a3a:	447f      	add	r7, pc
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    8a3c:	22c2      	movs	r2, #194	; 0xc2
    8a3e:	00d2      	lsls	r2, r2, #3
    8a40:	4b62      	ldr	r3, [pc, #392]	; (8bcc <system_clock_init+0x19c>)
    8a42:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    8a44:	4a62      	ldr	r2, [pc, #392]	; (8bd0 <system_clock_init+0x1a0>)
    8a46:	6853      	ldr	r3, [r2, #4]
    8a48:	211e      	movs	r1, #30
    8a4a:	438b      	bics	r3, r1
    8a4c:	391c      	subs	r1, #28
    8a4e:	430b      	orrs	r3, r1
    8a50:	6053      	str	r3, [r2, #4]
	gclk_conf.source_generator = GCLK_GENERATOR_3;
    8a52:	2203      	movs	r2, #3
    8a54:	ab05      	add	r3, sp, #20
    8a56:	701a      	strb	r2, [r3, #0]
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    8a58:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    8a5a:	001e      	movs	r6, r3
    8a5c:	4b5d      	ldr	r3, [pc, #372]	; (8bd4 <system_clock_init+0x1a4>)
    8a5e:	58fd      	ldr	r5, [r7, r3]
    8a60:	b2e0      	uxtb	r0, r4
    8a62:	0031      	movs	r1, r6
    8a64:	47a8      	blx	r5
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    8a66:	3401      	adds	r4, #1
    8a68:	2c25      	cmp	r4, #37	; 0x25
    8a6a:	d1f9      	bne.n	8a60 <system_clock_init+0x30>
	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    8a6c:	2300      	movs	r3, #0
    8a6e:	a80e      	add	r0, sp, #56	; 0x38
    8a70:	7003      	strb	r3, [r0, #0]
	config->frequency           = 32768UL;
    8a72:	2280      	movs	r2, #128	; 0x80
    8a74:	0212      	lsls	r2, r2, #8
    8a76:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    8a78:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    8a7a:	2201      	movs	r2, #1
    8a7c:	7102      	strb	r2, [r0, #4]
	config->write_once          = false;
    8a7e:	7383      	strb	r3, [r0, #14]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    8a80:	2102      	movs	r1, #2
    8a82:	7041      	strb	r1, [r0, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
    8a84:	7082      	strb	r2, [r0, #2]
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    8a86:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
    8a88:	7302      	strb	r2, [r0, #12]

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    8a8a:	4b53      	ldr	r3, [pc, #332]	; (8bd8 <system_clock_init+0x1a8>)
    8a8c:	58fb      	ldr	r3, [r7, r3]
    8a8e:	9301      	str	r3, [sp, #4]
    8a90:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    8a92:	2005      	movs	r0, #5
    8a94:	4b51      	ldr	r3, [pc, #324]	; (8bdc <system_clock_init+0x1ac>)
    8a96:	58fb      	ldr	r3, [r7, r3]
    8a98:	9301      	str	r3, [sp, #4]
    8a9a:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    8a9c:	4b50      	ldr	r3, [pc, #320]	; (8be0 <system_clock_init+0x1b0>)
    8a9e:	58fc      	ldr	r4, [r7, r3]
    8aa0:	2005      	movs	r0, #5
    8aa2:	47a0      	blx	r4
    8aa4:	2800      	cmp	r0, #0
    8aa6:	d0fb      	beq.n	8aa0 <system_clock_init+0x70>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
    8aa8:	4a48      	ldr	r2, [pc, #288]	; (8bcc <system_clock_init+0x19c>)
    8aaa:	8a93      	ldrh	r3, [r2, #20]
    8aac:	2180      	movs	r1, #128	; 0x80
    8aae:	430b      	orrs	r3, r1
    8ab0:	8293      	strh	r3, [r2, #20]
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    8ab2:	2100      	movs	r1, #0
    8ab4:	2200      	movs	r2, #0
    8ab6:	ab09      	add	r3, sp, #36	; 0x24
    8ab8:	8059      	strh	r1, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    8aba:	8099      	strh	r1, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    8abc:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    8abe:	71da      	strb	r2, [r3, #7]
	config->fine_value      = 0xff / 4; /* Midpoint */
    8ac0:	313f      	adds	r1, #63	; 0x3f
    8ac2:	8159      	strh	r1, [r3, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    8ac4:	393b      	subs	r1, #59	; 0x3b
    8ac6:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    8ac8:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    8aca:	4b46      	ldr	r3, [pc, #280]	; (8be4 <system_clock_init+0x1b4>)
    8acc:	681b      	ldr	r3, [r3, #0]
    8ace:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
    8ad0:	2b3f      	cmp	r3, #63	; 0x3f
    8ad2:	d100      	bne.n	8ad6 <system_clock_init+0xa6>
    8ad4:	e076      	b.n	8bc4 <system_clock_init+0x194>
		coarse = 0x1f;
	}
	dfll_conf.coarse_value = coarse;
    8ad6:	a809      	add	r0, sp, #36	; 0x24
    8ad8:	7203      	strb	r3, [r0, #8]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    8ada:	4b43      	ldr	r3, [pc, #268]	; (8be8 <system_clock_init+0x1b8>)
    8adc:	8203      	strh	r3, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    8ade:	2307      	movs	r3, #7
    8ae0:	7303      	strb	r3, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    8ae2:	3338      	adds	r3, #56	; 0x38
    8ae4:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    8ae6:	4b41      	ldr	r3, [pc, #260]	; (8bec <system_clock_init+0x1bc>)
    8ae8:	58fb      	ldr	r3, [r7, r3]
    8aea:	9301      	str	r3, [sp, #4]
    8aec:	4798      	blx	r3
	config->run_in_standby  = false;
    8aee:	2600      	movs	r6, #0
    8af0:	a808      	add	r0, sp, #32
    8af2:	7046      	strb	r6, [r0, #1]
	config->on_demand       = true;
    8af4:	2501      	movs	r5, #1
    8af6:	7085      	strb	r5, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    8af8:	7006      	strb	r6, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    8afa:	4b3d      	ldr	r3, [pc, #244]	; (8bf0 <system_clock_init+0x1c0>)
    8afc:	58fb      	ldr	r3, [r7, r3]
    8afe:	9301      	str	r3, [sp, #4]
    8b00:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    8b02:	2006      	movs	r0, #6
    8b04:	4b35      	ldr	r3, [pc, #212]	; (8bdc <system_clock_init+0x1ac>)
    8b06:	58fb      	ldr	r3, [r7, r3]
    8b08:	9301      	str	r3, [sp, #4]
    8b0a:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    8b0c:	4b39      	ldr	r3, [pc, #228]	; (8bf4 <system_clock_init+0x1c4>)
    8b0e:	58f9      	ldr	r1, [r7, r3]
    8b10:	9102      	str	r1, [sp, #8]
    8b12:	4788      	blx	r1
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    8b14:	ac05      	add	r4, sp, #20
    8b16:	9506      	str	r5, [sp, #24]
	config->high_when_disabled = false;
    8b18:	7066      	strb	r6, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    8b1a:	7226      	strb	r6, [r4, #8]
	config->output_enable      = false;
    8b1c:	7266      	strb	r6, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    8b1e:	2105      	movs	r1, #5
    8b20:	4688      	mov	r8, r1
    8b22:	7021      	strb	r1, [r4, #0]
    8b24:	0021      	movs	r1, r4
    8b26:	2001      	movs	r0, #1
    8b28:	4b33      	ldr	r3, [pc, #204]	; (8bf8 <system_clock_init+0x1c8>)
    8b2a:	58fb      	ldr	r3, [r7, r3]
    8b2c:	9302      	str	r3, [sp, #8]
    8b2e:	469c      	mov	ip, r3
    8b30:	47e0      	blx	ip
    8b32:	2001      	movs	r0, #1
    8b34:	4b31      	ldr	r3, [pc, #196]	; (8bfc <system_clock_init+0x1cc>)
    8b36:	58f9      	ldr	r1, [r7, r3]
    8b38:	9103      	str	r1, [sp, #12]
    8b3a:	4788      	blx	r1
	config->high_when_disabled = false;
    8b3c:	7066      	strb	r6, [r4, #1]
	config->output_enable      = false;
    8b3e:	7266      	strb	r6, [r4, #9]
    8b40:	4640      	mov	r0, r8
    8b42:	7020      	strb	r0, [r4, #0]
    8b44:	2320      	movs	r3, #32
    8b46:	6063      	str	r3, [r4, #4]
    8b48:	7225      	strb	r5, [r4, #8]
    8b4a:	0021      	movs	r1, r4
    8b4c:	2002      	movs	r0, #2
    8b4e:	9e02      	ldr	r6, [sp, #8]
    8b50:	47b0      	blx	r6
    8b52:	2002      	movs	r0, #2
    8b54:	9903      	ldr	r1, [sp, #12]
    8b56:	4788      	blx	r1
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    8b58:	7025      	strb	r5, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    8b5a:	0021      	movs	r1, r4
    8b5c:	2000      	movs	r0, #0
    8b5e:	4b1d      	ldr	r3, [pc, #116]	; (8bd4 <system_clock_init+0x1a4>)
    8b60:	58fc      	ldr	r4, [r7, r3]
    8b62:	9402      	str	r4, [sp, #8]
    8b64:	47a0      	blx	r4
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    8b66:	2000      	movs	r0, #0
    8b68:	4b25      	ldr	r3, [pc, #148]	; (8c00 <system_clock_init+0x1d0>)
    8b6a:	58f9      	ldr	r1, [r7, r3]
    8b6c:	9102      	str	r1, [sp, #8]
    8b6e:	4788      	blx	r1
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    8b70:	2007      	movs	r0, #7
    8b72:	9a01      	ldr	r2, [sp, #4]
    8b74:	4790      	blx	r2
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    8b76:	4b1a      	ldr	r3, [pc, #104]	; (8be0 <system_clock_init+0x1b0>)
    8b78:	58fc      	ldr	r4, [r7, r3]
    8b7a:	2007      	movs	r0, #7
    8b7c:	47a0      	blx	r4
    8b7e:	2800      	cmp	r0, #0
    8b80:	d0fb      	beq.n	8b7a <system_clock_init+0x14a>
	if (CONF_CLOCK_DFLL_ON_DEMAND) {
		SYSCTRL->DFLLCTRL.bit.ONDEMAND = 1;
    8b82:	4a12      	ldr	r2, [pc, #72]	; (8bcc <system_clock_init+0x19c>)
    8b84:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    8b86:	2180      	movs	r1, #128	; 0x80
    8b88:	430b      	orrs	r3, r1
    8b8a:	8493      	strh	r3, [r2, #36]	; 0x24
	PM->CPUSEL.reg = (uint32_t)divider;
    8b8c:	4a1d      	ldr	r2, [pc, #116]	; (8c04 <system_clock_init+0x1d4>)
    8b8e:	2300      	movs	r3, #0
    8b90:	7213      	strb	r3, [r2, #8]
			PM->APBASEL.reg = (uint32_t)divider;
    8b92:	7253      	strb	r3, [r2, #9]
			PM->APBBSEL.reg = (uint32_t)divider;
    8b94:	7293      	strb	r3, [r2, #10]
			PM->APBCSEL.reg = (uint32_t)divider;
    8b96:	72d3      	strb	r3, [r2, #11]
	config->division_factor    = 1;
    8b98:	2201      	movs	r2, #1
    8b9a:	a905      	add	r1, sp, #20
    8b9c:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    8b9e:	704b      	strb	r3, [r1, #1]
	config->run_in_standby     = false;
    8ba0:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    8ba2:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    8ba4:	3307      	adds	r3, #7
    8ba6:	700b      	strb	r3, [r1, #0]
    8ba8:	2000      	movs	r0, #0
    8baa:	4b13      	ldr	r3, [pc, #76]	; (8bf8 <system_clock_init+0x1c8>)
    8bac:	58fb      	ldr	r3, [r7, r3]
    8bae:	9301      	str	r3, [sp, #4]
    8bb0:	4798      	blx	r3
    8bb2:	2000      	movs	r0, #0
    8bb4:	4b11      	ldr	r3, [pc, #68]	; (8bfc <system_clock_init+0x1cc>)
    8bb6:	58fb      	ldr	r3, [r7, r3]
    8bb8:	9301      	str	r3, [sp, #4]
    8bba:	4798      	blx	r3
#endif
}
    8bbc:	b012      	add	sp, #72	; 0x48
    8bbe:	bc04      	pop	{r2}
    8bc0:	4690      	mov	r8, r2
    8bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		coarse = 0x1f;
    8bc4:	3b20      	subs	r3, #32
    8bc6:	e786      	b.n	8ad6 <system_clock_init+0xa6>
    8bc8:	0000106a 	.word	0x0000106a
    8bcc:	40000800 	.word	0x40000800
    8bd0:	41004000 	.word	0x41004000
    8bd4:	0000002c 	.word	0x0000002c
    8bd8:	00000074 	.word	0x00000074
    8bdc:	00000088 	.word	0x00000088
    8be0:	00000098 	.word	0x00000098
    8be4:	00806024 	.word	0x00806024
    8be8:	000005dc 	.word	0x000005dc
    8bec:	00000018 	.word	0x00000018
    8bf0:	00000048 	.word	0x00000048
    8bf4:	000000a8 	.word	0x000000a8
    8bf8:	00000040 	.word	0x00000040
    8bfc:	00000060 	.word	0x00000060
    8c00:	00000078 	.word	0x00000078
    8c04:	40000400 	.word	0x40000400

00008c08 <system_gclk_init>:
			PM->APBAMASK.reg |= mask;
    8c08:	4a06      	ldr	r2, [pc, #24]	; (8c24 <system_gclk_init+0x1c>)
    8c0a:	6993      	ldr	r3, [r2, #24]
    8c0c:	2108      	movs	r1, #8
    8c0e:	430b      	orrs	r3, r1
    8c10:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    8c12:	2201      	movs	r2, #1
    8c14:	4b04      	ldr	r3, [pc, #16]	; (8c28 <system_gclk_init+0x20>)
    8c16:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    8c18:	0019      	movs	r1, r3
    8c1a:	780b      	ldrb	r3, [r1, #0]
    8c1c:	4213      	tst	r3, r2
    8c1e:	d1fc      	bne.n	8c1a <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    8c20:	4770      	bx	lr
    8c22:	46c0      	nop			; (mov r8, r8)
    8c24:	40000400 	.word	0x40000400
    8c28:	40000c00 	.word	0x40000c00

00008c2c <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    8c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8c2e:	b083      	sub	sp, #12
    8c30:	0007      	movs	r7, r0
    8c32:	4e2c      	ldr	r6, [pc, #176]	; (8ce4 <system_gclk_gen_set_config+0xb8>)
    8c34:	447e      	add	r6, pc
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    8c36:	0004      	movs	r4, r0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    8c38:	780d      	ldrb	r5, [r1, #0]
    8c3a:	022d      	lsls	r5, r5, #8
    8c3c:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    8c3e:	784b      	ldrb	r3, [r1, #1]
    8c40:	2b00      	cmp	r3, #0
    8c42:	d002      	beq.n	8c4a <system_gclk_gen_set_config+0x1e>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    8c44:	2380      	movs	r3, #128	; 0x80
    8c46:	02db      	lsls	r3, r3, #11
    8c48:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    8c4a:	7a4b      	ldrb	r3, [r1, #9]
    8c4c:	2b00      	cmp	r3, #0
    8c4e:	d002      	beq.n	8c56 <system_gclk_gen_set_config+0x2a>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    8c50:	2380      	movs	r3, #128	; 0x80
    8c52:	031b      	lsls	r3, r3, #12
    8c54:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    8c56:	6848      	ldr	r0, [r1, #4]
    8c58:	2801      	cmp	r0, #1
    8c5a:	d910      	bls.n	8c7e <system_gclk_gen_set_config+0x52>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    8c5c:	1e43      	subs	r3, r0, #1
    8c5e:	4218      	tst	r0, r3
    8c60:	d139      	bne.n	8cd6 <system_gclk_gen_set_config+0xaa>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    8c62:	2802      	cmp	r0, #2
    8c64:	d935      	bls.n	8cd2 <system_gclk_gen_set_config+0xa6>
    8c66:	2302      	movs	r3, #2
    8c68:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    8c6a:	3201      	adds	r2, #1
						mask <<= 1) {
    8c6c:	005b      	lsls	r3, r3, #1
			for (mask = (1UL << 1); mask < config->division_factor;
    8c6e:	4298      	cmp	r0, r3
    8c70:	d8fb      	bhi.n	8c6a <system_gclk_gen_set_config+0x3e>
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    8c72:	0212      	lsls	r2, r2, #8
    8c74:	433a      	orrs	r2, r7
    8c76:	0014      	movs	r4, r2
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    8c78:	2380      	movs	r3, #128	; 0x80
    8c7a:	035b      	lsls	r3, r3, #13
    8c7c:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    8c7e:	7a0b      	ldrb	r3, [r1, #8]
    8c80:	2b00      	cmp	r3, #0
    8c82:	d002      	beq.n	8c8a <system_gclk_gen_set_config+0x5e>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    8c84:	2380      	movs	r3, #128	; 0x80
    8c86:	039b      	lsls	r3, r3, #14
    8c88:	431d      	orrs	r5, r3
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8c8a:	4a17      	ldr	r2, [pc, #92]	; (8ce8 <system_gclk_gen_set_config+0xbc>)
    8c8c:	7853      	ldrb	r3, [r2, #1]
	}

	while (system_gclk_is_syncing()) {
    8c8e:	b25b      	sxtb	r3, r3
    8c90:	2b00      	cmp	r3, #0
    8c92:	dbfb      	blt.n	8c8c <system_gclk_gen_set_config+0x60>
	cpu_irq_enter_critical();
    8c94:	4b15      	ldr	r3, [pc, #84]	; (8cec <system_gclk_gen_set_config+0xc0>)
    8c96:	58f3      	ldr	r3, [r6, r3]
    8c98:	9301      	str	r3, [sp, #4]
    8c9a:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    8c9c:	4b14      	ldr	r3, [pc, #80]	; (8cf0 <system_gclk_gen_set_config+0xc4>)
    8c9e:	701f      	strb	r7, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8ca0:	4a11      	ldr	r2, [pc, #68]	; (8ce8 <system_gclk_gen_set_config+0xbc>)
    8ca2:	7853      	ldrb	r3, [r2, #1]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    8ca4:	b25b      	sxtb	r3, r3
    8ca6:	2b00      	cmp	r3, #0
    8ca8:	dbfb      	blt.n	8ca2 <system_gclk_gen_set_config+0x76>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    8caa:	4b0f      	ldr	r3, [pc, #60]	; (8ce8 <system_gclk_gen_set_config+0xbc>)
    8cac:	609c      	str	r4, [r3, #8]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8cae:	001a      	movs	r2, r3
    8cb0:	7853      	ldrb	r3, [r2, #1]

	while (system_gclk_is_syncing()) {
    8cb2:	b25b      	sxtb	r3, r3
    8cb4:	2b00      	cmp	r3, #0
    8cb6:	dbfb      	blt.n	8cb0 <system_gclk_gen_set_config+0x84>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    8cb8:	4a0b      	ldr	r2, [pc, #44]	; (8ce8 <system_gclk_gen_set_config+0xbc>)
    8cba:	6853      	ldr	r3, [r2, #4]
    8cbc:	2180      	movs	r1, #128	; 0x80
    8cbe:	0249      	lsls	r1, r1, #9
    8cc0:	400b      	ands	r3, r1
    8cc2:	431d      	orrs	r5, r3
    8cc4:	6055      	str	r5, [r2, #4]
	cpu_irq_leave_critical();
    8cc6:	4b0b      	ldr	r3, [pc, #44]	; (8cf4 <system_gclk_gen_set_config+0xc8>)
    8cc8:	58f3      	ldr	r3, [r6, r3]
    8cca:	9301      	str	r3, [sp, #4]
    8ccc:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    8cce:	b003      	add	sp, #12
    8cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			for (mask = (1UL << 1); mask < config->division_factor;
    8cd2:	2200      	movs	r2, #0
    8cd4:	e7cd      	b.n	8c72 <system_gclk_gen_set_config+0x46>
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    8cd6:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |=
    8cd8:	433c      	orrs	r4, r7
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    8cda:	2380      	movs	r3, #128	; 0x80
    8cdc:	029b      	lsls	r3, r3, #10
    8cde:	431d      	orrs	r5, r3
    8ce0:	e7cd      	b.n	8c7e <system_gclk_gen_set_config+0x52>
    8ce2:	46c0      	nop			; (mov r8, r8)
    8ce4:	00000e70 	.word	0x00000e70
    8ce8:	40000c00 	.word	0x40000c00
    8cec:	00000034 	.word	0x00000034
    8cf0:	40000c08 	.word	0x40000c08
    8cf4:	00000000 	.word	0x00000000

00008cf8 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    8cf8:	b530      	push	{r4, r5, lr}
    8cfa:	b083      	sub	sp, #12
    8cfc:	0005      	movs	r5, r0
    8cfe:	4c0f      	ldr	r4, [pc, #60]	; (8d3c <system_gclk_gen_enable+0x44>)
    8d00:	447c      	add	r4, pc
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8d02:	4a0f      	ldr	r2, [pc, #60]	; (8d40 <system_gclk_gen_enable+0x48>)
    8d04:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    8d06:	b25b      	sxtb	r3, r3
    8d08:	2b00      	cmp	r3, #0
    8d0a:	dbfb      	blt.n	8d04 <system_gclk_gen_enable+0xc>
	cpu_irq_enter_critical();
    8d0c:	4b0d      	ldr	r3, [pc, #52]	; (8d44 <system_gclk_gen_enable+0x4c>)
    8d0e:	58e3      	ldr	r3, [r4, r3]
    8d10:	9301      	str	r3, [sp, #4]
    8d12:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    8d14:	4b0c      	ldr	r3, [pc, #48]	; (8d48 <system_gclk_gen_enable+0x50>)
    8d16:	701d      	strb	r5, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8d18:	4a09      	ldr	r2, [pc, #36]	; (8d40 <system_gclk_gen_enable+0x48>)
    8d1a:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    8d1c:	b25b      	sxtb	r3, r3
    8d1e:	2b00      	cmp	r3, #0
    8d20:	dbfb      	blt.n	8d1a <system_gclk_gen_enable+0x22>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    8d22:	4a07      	ldr	r2, [pc, #28]	; (8d40 <system_gclk_gen_enable+0x48>)
    8d24:	6851      	ldr	r1, [r2, #4]
    8d26:	2380      	movs	r3, #128	; 0x80
    8d28:	025b      	lsls	r3, r3, #9
    8d2a:	430b      	orrs	r3, r1
    8d2c:	6053      	str	r3, [r2, #4]
	cpu_irq_leave_critical();
    8d2e:	4b07      	ldr	r3, [pc, #28]	; (8d4c <system_gclk_gen_enable+0x54>)
    8d30:	58e3      	ldr	r3, [r4, r3]
    8d32:	9301      	str	r3, [sp, #4]
    8d34:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    8d36:	b003      	add	sp, #12
    8d38:	bd30      	pop	{r4, r5, pc}
    8d3a:	46c0      	nop			; (mov r8, r8)
    8d3c:	00000da4 	.word	0x00000da4
    8d40:	40000c00 	.word	0x40000c00
    8d44:	00000034 	.word	0x00000034
    8d48:	40000c04 	.word	0x40000c04
    8d4c:	00000000 	.word	0x00000000

00008d50 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    8d50:	b5f0      	push	{r4, r5, r6, r7, lr}
    8d52:	b083      	sub	sp, #12
    8d54:	0006      	movs	r6, r0
    8d56:	4c20      	ldr	r4, [pc, #128]	; (8dd8 <system_gclk_gen_get_hz+0x88>)
    8d58:	447c      	add	r4, pc
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8d5a:	4a20      	ldr	r2, [pc, #128]	; (8ddc <system_gclk_gen_get_hz+0x8c>)
    8d5c:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    8d5e:	b25b      	sxtb	r3, r3
    8d60:	2b00      	cmp	r3, #0
    8d62:	dbfb      	blt.n	8d5c <system_gclk_gen_get_hz+0xc>
	cpu_irq_enter_critical();
    8d64:	4b1e      	ldr	r3, [pc, #120]	; (8de0 <system_gclk_gen_get_hz+0x90>)
    8d66:	58e3      	ldr	r3, [r4, r3]
    8d68:	9301      	str	r3, [sp, #4]
    8d6a:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    8d6c:	4b1d      	ldr	r3, [pc, #116]	; (8de4 <system_gclk_gen_get_hz+0x94>)
    8d6e:	701e      	strb	r6, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8d70:	4a1a      	ldr	r2, [pc, #104]	; (8ddc <system_gclk_gen_get_hz+0x8c>)
    8d72:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    8d74:	b25b      	sxtb	r3, r3
    8d76:	2b00      	cmp	r3, #0
    8d78:	dbfb      	blt.n	8d72 <system_gclk_gen_get_hz+0x22>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    8d7a:	4f18      	ldr	r7, [pc, #96]	; (8ddc <system_gclk_gen_get_hz+0x8c>)
    8d7c:	6878      	ldr	r0, [r7, #4]
    8d7e:	04c0      	lsls	r0, r0, #19
    8d80:	0ec0      	lsrs	r0, r0, #27
	uint32_t gen_input_hz = system_clock_source_get_hz(
    8d82:	4b19      	ldr	r3, [pc, #100]	; (8de8 <system_gclk_gen_get_hz+0x98>)
    8d84:	58e3      	ldr	r3, [r4, r3]
    8d86:	9301      	str	r3, [sp, #4]
    8d88:	4798      	blx	r3
    8d8a:	0005      	movs	r5, r0

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    8d8c:	4b15      	ldr	r3, [pc, #84]	; (8de4 <system_gclk_gen_get_hz+0x94>)
    8d8e:	701e      	strb	r6, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    8d90:	687f      	ldr	r7, [r7, #4]
    8d92:	02ff      	lsls	r7, r7, #11
    8d94:	0fff      	lsrs	r7, r7, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    8d96:	4b15      	ldr	r3, [pc, #84]	; (8dec <system_gclk_gen_get_hz+0x9c>)
    8d98:	701e      	strb	r6, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    8d9a:	4a10      	ldr	r2, [pc, #64]	; (8ddc <system_gclk_gen_get_hz+0x8c>)
    8d9c:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    8d9e:	b25b      	sxtb	r3, r3
    8da0:	2b00      	cmp	r3, #0
    8da2:	dbfb      	blt.n	8d9c <system_gclk_gen_get_hz+0x4c>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    8da4:	4b0d      	ldr	r3, [pc, #52]	; (8ddc <system_gclk_gen_get_hz+0x8c>)
    8da6:	689e      	ldr	r6, [r3, #8]
    8da8:	0236      	lsls	r6, r6, #8
    8daa:	0c36      	lsrs	r6, r6, #16
	cpu_irq_leave_critical();
    8dac:	4b10      	ldr	r3, [pc, #64]	; (8df0 <system_gclk_gen_get_hz+0xa0>)
    8dae:	58e3      	ldr	r3, [r4, r3]
    8db0:	9301      	str	r3, [sp, #4]
    8db2:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    8db4:	2f00      	cmp	r7, #0
    8db6:	d109      	bne.n	8dcc <system_gclk_gen_get_hz+0x7c>
    8db8:	2e01      	cmp	r6, #1
    8dba:	d909      	bls.n	8dd0 <system_gclk_gen_get_hz+0x80>
		gen_input_hz /= divider;
    8dbc:	4b0d      	ldr	r3, [pc, #52]	; (8df4 <system_gclk_gen_get_hz+0xa4>)
    8dbe:	58e3      	ldr	r3, [r4, r3]
    8dc0:	9301      	str	r3, [sp, #4]
    8dc2:	0031      	movs	r1, r6
    8dc4:	0028      	movs	r0, r5
    8dc6:	4798      	blx	r3
    8dc8:	0005      	movs	r5, r0
    8dca:	e001      	b.n	8dd0 <system_gclk_gen_get_hz+0x80>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    8dcc:	3601      	adds	r6, #1
    8dce:	40f5      	lsrs	r5, r6
	}

	return gen_input_hz;
}
    8dd0:	0028      	movs	r0, r5
    8dd2:	b003      	add	sp, #12
    8dd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8dd6:	46c0      	nop			; (mov r8, r8)
    8dd8:	00000d4c 	.word	0x00000d4c
    8ddc:	40000c00 	.word	0x40000c00
    8de0:	00000034 	.word	0x00000034
    8de4:	40000c04 	.word	0x40000c04
    8de8:	0000008c 	.word	0x0000008c
    8dec:	40000c08 	.word	0x40000c08
    8df0:	00000000 	.word	0x00000000
    8df4:	0000006c 	.word	0x0000006c

00008df8 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    8df8:	b530      	push	{r4, r5, lr}
    8dfa:	b083      	sub	sp, #12
    8dfc:	0005      	movs	r5, r0
    8dfe:	4c0a      	ldr	r4, [pc, #40]	; (8e28 <system_gclk_chan_enable+0x30>)
    8e00:	447c      	add	r4, pc
	cpu_irq_enter_critical();
    8e02:	4b0a      	ldr	r3, [pc, #40]	; (8e2c <system_gclk_chan_enable+0x34>)
    8e04:	58e3      	ldr	r3, [r4, r3]
    8e06:	9301      	str	r3, [sp, #4]
    8e08:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    8e0a:	4b09      	ldr	r3, [pc, #36]	; (8e30 <system_gclk_chan_enable+0x38>)
    8e0c:	701d      	strb	r5, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    8e0e:	4a09      	ldr	r2, [pc, #36]	; (8e34 <system_gclk_chan_enable+0x3c>)
    8e10:	8853      	ldrh	r3, [r2, #2]
    8e12:	2180      	movs	r1, #128	; 0x80
    8e14:	01c9      	lsls	r1, r1, #7
    8e16:	430b      	orrs	r3, r1
    8e18:	8053      	strh	r3, [r2, #2]
	cpu_irq_leave_critical();
    8e1a:	4b07      	ldr	r3, [pc, #28]	; (8e38 <system_gclk_chan_enable+0x40>)
    8e1c:	58e3      	ldr	r3, [r4, r3]
    8e1e:	9301      	str	r3, [sp, #4]
    8e20:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    8e22:	b003      	add	sp, #12
    8e24:	bd30      	pop	{r4, r5, pc}
    8e26:	46c0      	nop			; (mov r8, r8)
    8e28:	00000ca4 	.word	0x00000ca4
    8e2c:	00000034 	.word	0x00000034
    8e30:	40000c02 	.word	0x40000c02
    8e34:	40000c00 	.word	0x40000c00
    8e38:	00000000 	.word	0x00000000

00008e3c <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    8e3c:	b530      	push	{r4, r5, lr}
    8e3e:	b083      	sub	sp, #12
    8e40:	0005      	movs	r5, r0
    8e42:	4c13      	ldr	r4, [pc, #76]	; (8e90 <system_gclk_chan_disable+0x54>)
    8e44:	447c      	add	r4, pc
	cpu_irq_enter_critical();
    8e46:	4b13      	ldr	r3, [pc, #76]	; (8e94 <system_gclk_chan_disable+0x58>)
    8e48:	58e3      	ldr	r3, [r4, r3]
    8e4a:	9301      	str	r3, [sp, #4]
    8e4c:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    8e4e:	4b12      	ldr	r3, [pc, #72]	; (8e98 <system_gclk_chan_disable+0x5c>)
    8e50:	701d      	strb	r5, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    8e52:	4a12      	ldr	r2, [pc, #72]	; (8e9c <system_gclk_chan_disable+0x60>)
    8e54:	8850      	ldrh	r0, [r2, #2]
    8e56:	0500      	lsls	r0, r0, #20
    8e58:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    8e5a:	8853      	ldrh	r3, [r2, #2]
    8e5c:	4910      	ldr	r1, [pc, #64]	; (8ea0 <system_gclk_chan_disable+0x64>)
    8e5e:	400b      	ands	r3, r1
    8e60:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    8e62:	8853      	ldrh	r3, [r2, #2]
    8e64:	490f      	ldr	r1, [pc, #60]	; (8ea4 <system_gclk_chan_disable+0x68>)
    8e66:	400b      	ands	r3, r1
    8e68:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    8e6a:	0011      	movs	r1, r2
    8e6c:	2280      	movs	r2, #128	; 0x80
    8e6e:	01d2      	lsls	r2, r2, #7
    8e70:	884b      	ldrh	r3, [r1, #2]
    8e72:	4213      	tst	r3, r2
    8e74:	d1fc      	bne.n	8e70 <system_gclk_chan_disable+0x34>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    8e76:	4909      	ldr	r1, [pc, #36]	; (8e9c <system_gclk_chan_disable+0x60>)
    8e78:	884b      	ldrh	r3, [r1, #2]
    8e7a:	0202      	lsls	r2, r0, #8
    8e7c:	4808      	ldr	r0, [pc, #32]	; (8ea0 <system_gclk_chan_disable+0x64>)
    8e7e:	4003      	ands	r3, r0
    8e80:	4313      	orrs	r3, r2
    8e82:	804b      	strh	r3, [r1, #2]
	cpu_irq_leave_critical();
    8e84:	4b08      	ldr	r3, [pc, #32]	; (8ea8 <system_gclk_chan_disable+0x6c>)
    8e86:	58e3      	ldr	r3, [r4, r3]
    8e88:	9301      	str	r3, [sp, #4]
    8e8a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    8e8c:	b003      	add	sp, #12
    8e8e:	bd30      	pop	{r4, r5, pc}
    8e90:	00000c60 	.word	0x00000c60
    8e94:	00000034 	.word	0x00000034
    8e98:	40000c02 	.word	0x40000c02
    8e9c:	40000c00 	.word	0x40000c00
    8ea0:	fffff0ff 	.word	0xfffff0ff
    8ea4:	ffffbfff 	.word	0xffffbfff
    8ea8:	00000000 	.word	0x00000000

00008eac <system_gclk_chan_set_config>:
{
    8eac:	b510      	push	{r4, lr}
    8eae:	b082      	sub	sp, #8
    8eb0:	4b06      	ldr	r3, [pc, #24]	; (8ecc <system_gclk_chan_set_config+0x20>)
    8eb2:	447b      	add	r3, pc
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    8eb4:	780c      	ldrb	r4, [r1, #0]
    8eb6:	0224      	lsls	r4, r4, #8
    8eb8:	4304      	orrs	r4, r0
	system_gclk_chan_disable(channel);
    8eba:	4a05      	ldr	r2, [pc, #20]	; (8ed0 <system_gclk_chan_set_config+0x24>)
    8ebc:	589b      	ldr	r3, [r3, r2]
    8ebe:	9301      	str	r3, [sp, #4]
    8ec0:	4798      	blx	r3
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    8ec2:	b2a4      	uxth	r4, r4
    8ec4:	4b03      	ldr	r3, [pc, #12]	; (8ed4 <system_gclk_chan_set_config+0x28>)
    8ec6:	805c      	strh	r4, [r3, #2]
}
    8ec8:	b002      	add	sp, #8
    8eca:	bd10      	pop	{r4, pc}
    8ecc:	00000bf2 	.word	0x00000bf2
    8ed0:	0000009c 	.word	0x0000009c
    8ed4:	40000c00 	.word	0x40000c00

00008ed8 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    8ed8:	b530      	push	{r4, r5, lr}
    8eda:	b083      	sub	sp, #12
    8edc:	0004      	movs	r4, r0
    8ede:	4d0b      	ldr	r5, [pc, #44]	; (8f0c <system_gclk_chan_get_hz+0x34>)
    8ee0:	447d      	add	r5, pc
	cpu_irq_enter_critical();
    8ee2:	4b0b      	ldr	r3, [pc, #44]	; (8f10 <system_gclk_chan_get_hz+0x38>)
    8ee4:	58eb      	ldr	r3, [r5, r3]
    8ee6:	9301      	str	r3, [sp, #4]
    8ee8:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    8eea:	4b0a      	ldr	r3, [pc, #40]	; (8f14 <system_gclk_chan_get_hz+0x3c>)
    8eec:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    8eee:	4b0a      	ldr	r3, [pc, #40]	; (8f18 <system_gclk_chan_get_hz+0x40>)
    8ef0:	885c      	ldrh	r4, [r3, #2]
    8ef2:	0524      	lsls	r4, r4, #20
    8ef4:	0f24      	lsrs	r4, r4, #28
	cpu_irq_leave_critical();
    8ef6:	4b09      	ldr	r3, [pc, #36]	; (8f1c <system_gclk_chan_get_hz+0x44>)
    8ef8:	58eb      	ldr	r3, [r5, r3]
    8efa:	9301      	str	r3, [sp, #4]
    8efc:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    8efe:	0020      	movs	r0, r4
    8f00:	4b07      	ldr	r3, [pc, #28]	; (8f20 <system_gclk_chan_get_hz+0x48>)
    8f02:	58eb      	ldr	r3, [r5, r3]
    8f04:	9301      	str	r3, [sp, #4]
    8f06:	4798      	blx	r3
}
    8f08:	b003      	add	sp, #12
    8f0a:	bd30      	pop	{r4, r5, pc}
    8f0c:	00000bc4 	.word	0x00000bc4
    8f10:	00000034 	.word	0x00000034
    8f14:	40000c02 	.word	0x40000c02
    8f18:	40000c00 	.word	0x40000c00
    8f1c:	00000000 	.word	0x00000000
    8f20:	00000038 	.word	0x00000038

00008f24 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    8f24:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    8f26:	78d3      	ldrb	r3, [r2, #3]
    8f28:	2b00      	cmp	r3, #0
    8f2a:	d135      	bne.n	8f98 <_system_pinmux_config+0x74>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    8f2c:	7813      	ldrb	r3, [r2, #0]
    8f2e:	2b80      	cmp	r3, #128	; 0x80
    8f30:	d029      	beq.n	8f86 <_system_pinmux_config+0x62>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    8f32:	061b      	lsls	r3, r3, #24
    8f34:	2480      	movs	r4, #128	; 0x80
    8f36:	0264      	lsls	r4, r4, #9
    8f38:	4323      	orrs	r3, r4
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    8f3a:	7854      	ldrb	r4, [r2, #1]
    8f3c:	2502      	movs	r5, #2
    8f3e:	43ac      	bics	r4, r5
    8f40:	d106      	bne.n	8f50 <_system_pinmux_config+0x2c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    8f42:	7894      	ldrb	r4, [r2, #2]
    8f44:	2c00      	cmp	r4, #0
    8f46:	d120      	bne.n	8f8a <_system_pinmux_config+0x66>
			pin_cfg |= PORT_WRCONFIG_INEN;
    8f48:	2480      	movs	r4, #128	; 0x80
    8f4a:	02a4      	lsls	r4, r4, #10
    8f4c:	4323      	orrs	r3, r4
				pin_cfg |= PORT_WRCONFIG_PULLEN;
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    8f4e:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    8f50:	7854      	ldrb	r4, [r2, #1]
    8f52:	3c01      	subs	r4, #1
    8f54:	2c01      	cmp	r4, #1
    8f56:	d91c      	bls.n	8f92 <_system_pinmux_config+0x6e>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    8f58:	040d      	lsls	r5, r1, #16
    8f5a:	0c2d      	lsrs	r5, r5, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    8f5c:	24a0      	movs	r4, #160	; 0xa0
    8f5e:	05e4      	lsls	r4, r4, #23
    8f60:	432c      	orrs	r4, r5
    8f62:	431c      	orrs	r4, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    8f64:	6284      	str	r4, [r0, #40]	; 0x28
	uint32_t upper_pin_mask = (pin_mask >> 16);
    8f66:	0c0d      	lsrs	r5, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    8f68:	24d0      	movs	r4, #208	; 0xd0
    8f6a:	0624      	lsls	r4, r4, #24
    8f6c:	432c      	orrs	r4, r5
    8f6e:	431c      	orrs	r4, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    8f70:	6284      	str	r4, [r0, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    8f72:	78d4      	ldrb	r4, [r2, #3]
    8f74:	2c00      	cmp	r4, #0
    8f76:	d122      	bne.n	8fbe <_system_pinmux_config+0x9a>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    8f78:	035b      	lsls	r3, r3, #13
    8f7a:	d51c      	bpl.n	8fb6 <_system_pinmux_config+0x92>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    8f7c:	7893      	ldrb	r3, [r2, #2]
    8f7e:	2b01      	cmp	r3, #1
    8f80:	d01e      	beq.n	8fc0 <_system_pinmux_config+0x9c>
				port->OUTSET.reg = pin_mask;
			} else {
				port->OUTCLR.reg = pin_mask;
    8f82:	6141      	str	r1, [r0, #20]
    8f84:	e017      	b.n	8fb6 <_system_pinmux_config+0x92>
	uint32_t pin_cfg = 0;
    8f86:	2300      	movs	r3, #0
    8f88:	e7d7      	b.n	8f3a <_system_pinmux_config+0x16>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    8f8a:	24c0      	movs	r4, #192	; 0xc0
    8f8c:	02e4      	lsls	r4, r4, #11
    8f8e:	4323      	orrs	r3, r4
    8f90:	e7dd      	b.n	8f4e <_system_pinmux_config+0x2a>
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    8f92:	4c0d      	ldr	r4, [pc, #52]	; (8fc8 <_system_pinmux_config+0xa4>)
    8f94:	4023      	ands	r3, r4
    8f96:	e7df      	b.n	8f58 <_system_pinmux_config+0x34>
		port->DIRCLR.reg = pin_mask;
    8f98:	6041      	str	r1, [r0, #4]
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    8f9a:	040c      	lsls	r4, r1, #16
    8f9c:	0c24      	lsrs	r4, r4, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    8f9e:	23a0      	movs	r3, #160	; 0xa0
    8fa0:	05db      	lsls	r3, r3, #23
    8fa2:	4323      	orrs	r3, r4
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    8fa4:	6283      	str	r3, [r0, #40]	; 0x28
	uint32_t upper_pin_mask = (pin_mask >> 16);
    8fa6:	0c0c      	lsrs	r4, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    8fa8:	23d0      	movs	r3, #208	; 0xd0
    8faa:	061b      	lsls	r3, r3, #24
    8fac:	4323      	orrs	r3, r4
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    8fae:	6283      	str	r3, [r0, #40]	; 0x28
	if(!config->powersave) {
    8fb0:	78d3      	ldrb	r3, [r2, #3]
    8fb2:	2b00      	cmp	r3, #0
    8fb4:	d103      	bne.n	8fbe <_system_pinmux_config+0x9a>
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    8fb6:	7853      	ldrb	r3, [r2, #1]
    8fb8:	3b01      	subs	r3, #1
    8fba:	2b01      	cmp	r3, #1
    8fbc:	d902      	bls.n	8fc4 <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
		}
	}
}
    8fbe:	bd30      	pop	{r4, r5, pc}
				port->OUTSET.reg = pin_mask;
    8fc0:	6181      	str	r1, [r0, #24]
    8fc2:	e7f8      	b.n	8fb6 <_system_pinmux_config+0x92>
			port->DIRSET.reg = pin_mask;
    8fc4:	6081      	str	r1, [r0, #8]
}
    8fc6:	e7fa      	b.n	8fbe <_system_pinmux_config+0x9a>
    8fc8:	fffbffff 	.word	0xfffbffff

00008fcc <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    8fcc:	b510      	push	{r4, lr}
    8fce:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    8fd0:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    8fd2:	2300      	movs	r3, #0
	if (port_index < PORT_INST_NUM) {
    8fd4:	2900      	cmp	r1, #0
    8fd6:	d104      	bne.n	8fe2 <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    8fd8:	0943      	lsrs	r3, r0, #5
    8fda:	01db      	lsls	r3, r3, #7
    8fdc:	4905      	ldr	r1, [pc, #20]	; (8ff4 <system_pinmux_pin_set_config+0x28>)
    8fde:	468c      	mov	ip, r1
    8fe0:	4463      	add	r3, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    8fe2:	241f      	movs	r4, #31
    8fe4:	4020      	ands	r0, r4
    8fe6:	2101      	movs	r1, #1
    8fe8:	4081      	lsls	r1, r0

	_system_pinmux_config(port, pin_mask, config);
    8fea:	0018      	movs	r0, r3
    8fec:	4b02      	ldr	r3, [pc, #8]	; (8ff8 <system_pinmux_pin_set_config+0x2c>)
    8fee:	447b      	add	r3, pc
    8ff0:	4798      	blx	r3
}
    8ff2:	bd10      	pop	{r4, pc}
    8ff4:	41004400 	.word	0x41004400
    8ff8:	ffffff33 	.word	0xffffff33

00008ffc <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    8ffc:	4770      	bx	lr
	...

00009000 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    9000:	b510      	push	{r4, lr}
    9002:	b082      	sub	sp, #8
    9004:	4c0b      	ldr	r4, [pc, #44]	; (9034 <system_init+0x34>)
    9006:	447c      	add	r4, pc
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    9008:	4b0b      	ldr	r3, [pc, #44]	; (9038 <system_init+0x38>)
    900a:	58e3      	ldr	r3, [r4, r3]
    900c:	9301      	str	r3, [sp, #4]
    900e:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    9010:	4b0a      	ldr	r3, [pc, #40]	; (903c <system_init+0x3c>)
    9012:	58e3      	ldr	r3, [r4, r3]
    9014:	9301      	str	r3, [sp, #4]
    9016:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    9018:	4b09      	ldr	r3, [pc, #36]	; (9040 <system_init+0x40>)
    901a:	58e3      	ldr	r3, [r4, r3]
    901c:	9301      	str	r3, [sp, #4]
    901e:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    9020:	4b08      	ldr	r3, [pc, #32]	; (9044 <system_init+0x44>)
    9022:	58e3      	ldr	r3, [r4, r3]
    9024:	9301      	str	r3, [sp, #4]
    9026:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    9028:	4b07      	ldr	r3, [pc, #28]	; (9048 <system_init+0x48>)
    902a:	58e3      	ldr	r3, [r4, r3]
    902c:	9301      	str	r3, [sp, #4]
    902e:	4798      	blx	r3
}
    9030:	b002      	add	sp, #8
    9032:	bd10      	pop	{r4, pc}
    9034:	00000a9e 	.word	0x00000a9e
    9038:	00000084 	.word	0x00000084
    903c:	0000005c 	.word	0x0000005c
    9040:	00000080 	.word	0x00000080
    9044:	0000004c 	.word	0x0000004c
    9048:	00000030 	.word	0x00000030

0000904c <USB_Handler>:

/**
 * \brief Interrupt handler for the USB module.
 */
void USB_Handler(void)
{
    904c:	b5f0      	push	{r4, r5, r6, r7, lr}
    904e:	46de      	mov	lr, fp
    9050:	4657      	mov	r7, sl
    9052:	464e      	mov	r6, r9
    9054:	4645      	mov	r5, r8
    9056:	b5e0      	push	{r5, r6, r7, lr}
    9058:	b083      	sub	sp, #12
    905a:	4f9b      	ldr	r7, [pc, #620]	; (92c8 <USB_Handler+0x27c>)
    905c:	447f      	add	r7, pc
	if (_usb_instances->hw->DEVICE.CTRLA.bit.MODE) {
    905e:	4b9b      	ldr	r3, [pc, #620]	; (92cc <USB_Handler+0x280>)
    9060:	447b      	add	r3, pc
    9062:	681e      	ldr	r6, [r3, #0]
    9064:	6835      	ldr	r5, [r6, #0]
    9066:	782b      	ldrb	r3, [r5, #0]
    9068:	09db      	lsrs	r3, r3, #7
    906a:	d120      	bne.n	90ae <USB_Handler+0x62>
	ep_inst = _usb_instances->hw->DEVICE.EPINTSMRY.reg;
    906c:	8c2b      	ldrh	r3, [r5, #32]
    906e:	b29b      	uxth	r3, r3
    9070:	469c      	mov	ip, r3
	if (0 == ep_inst) {
    9072:	2b00      	cmp	r3, #0
    9074:	d000      	beq.n	9078 <USB_Handler+0x2c>
    9076:	e208      	b.n	948a <USB_Handler+0x43e>
		flags = _usb_instances->hw->DEVICE.INTFLAG.reg;
    9078:	8bab      	ldrh	r3, [r5, #28]
    907a:	b29b      	uxth	r3, r3
    907c:	4698      	mov	r8, r3
				_usb_instances->device_enabled_callback_mask &
    907e:	23ab      	movs	r3, #171	; 0xab
    9080:	005b      	lsls	r3, r3, #1
		flags_run = flags &
    9082:	5af3      	ldrh	r3, [r6, r3]
    9084:	22aa      	movs	r2, #170	; 0xaa
    9086:	0052      	lsls	r2, r2, #1
    9088:	5ab5      	ldrh	r5, [r6, r2]
    908a:	401d      	ands	r5, r3
    908c:	4643      	mov	r3, r8
    908e:	401d      	ands	r5, r3
		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
    9090:	2400      	movs	r4, #0
			if (flags & _usb_device_irq_bits[i]) {
    9092:	4e8f      	ldr	r6, [pc, #572]	; (92d0 <USB_Handler+0x284>)
    9094:	447e      	add	r6, pc
				_usb_instances->hw->DEVICE.INTFLAG.reg =
    9096:	4b8f      	ldr	r3, [pc, #572]	; (92d4 <USB_Handler+0x288>)
    9098:	447b      	add	r3, pc
    909a:	4699      	mov	r9, r3
							& USB_LPM_ATTRIBUT_REMOTEWAKE_MASK;
    909c:	2380      	movs	r3, #128	; 0x80
    909e:	005b      	lsls	r3, r3, #1
    90a0:	469a      	mov	sl, r3
    90a2:	0033      	movs	r3, r6
    90a4:	002e      	movs	r6, r5
    90a6:	4645      	mov	r5, r8
    90a8:	46b8      	mov	r8, r7
    90aa:	001f      	movs	r7, r3
    90ac:	e1d5      	b.n	945a <USB_Handler+0x40e>
	pipe_int = ctz(_usb_instances->hw->HOST.PINTSMRY.reg);
    90ae:	8c2b      	ldrh	r3, [r5, #32]
    90b0:	b29b      	uxth	r3, r3
    90b2:	2b00      	cmp	r3, #0
    90b4:	d100      	bne.n	90b8 <USB_Handler+0x6c>
    90b6:	e131      	b.n	931c <USB_Handler+0x2d0>
    90b8:	8c28      	ldrh	r0, [r5, #32]
    90ba:	b280      	uxth	r0, r0
    90bc:	4b86      	ldr	r3, [pc, #536]	; (92d8 <USB_Handler+0x28c>)
    90be:	58fb      	ldr	r3, [r7, r3]
    90c0:	9300      	str	r3, [sp, #0]
    90c2:	4798      	blx	r3
    90c4:	0004      	movs	r4, r0
	if (pipe_int < 32) {
    90c6:	281f      	cmp	r0, #31
    90c8:	d900      	bls.n	90cc <USB_Handler+0x80>
    90ca:	e127      	b.n	931c <USB_Handler+0x2d0>
		flags = _usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg;
    90cc:	0003      	movs	r3, r0
    90ce:	3308      	adds	r3, #8
    90d0:	015b      	lsls	r3, r3, #5
    90d2:	18ed      	adds	r5, r5, r3
    90d4:	79ed      	ldrb	r5, [r5, #7]
    90d6:	b2ed      	uxtb	r5, r5
		if (flags & USB_HOST_PINTFLAG_TRCPT_Msk) {
    90d8:	07ab      	lsls	r3, r5, #30
    90da:	d04f      	beq.n	917c <USB_Handler+0x130>
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    90dc:	4b7f      	ldr	r3, [pc, #508]	; (92dc <USB_Handler+0x290>)
    90de:	58fa      	ldr	r2, [r7, r3]
    90e0:	2301      	movs	r3, #1
    90e2:	4083      	lsls	r3, r0
    90e4:	6811      	ldr	r1, [r2, #0]
    90e6:	4399      	bics	r1, r3
    90e8:	6011      	str	r1, [r2, #0]
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    90ea:	0003      	movs	r3, r0
    90ec:	3308      	adds	r3, #8
    90ee:	015b      	lsls	r3, r3, #5
    90f0:	6832      	ldr	r2, [r6, #0]
    90f2:	4694      	mov	ip, r2
    90f4:	4463      	add	r3, ip
    90f6:	2203      	movs	r2, #3
    90f8:	71da      	strb	r2, [r3, #7]
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    90fa:	1833      	adds	r3, r6, r0
    90fc:	33ae      	adds	r3, #174	; 0xae
    90fe:	781b      	ldrb	r3, [r3, #0]
    9100:	07db      	lsls	r3, r3, #31
    9102:	d53b      	bpl.n	917c <USB_Handler+0x130>
				pipe_callback_para.pipe_num = pipe_int;
    9104:	4b76      	ldr	r3, [pc, #472]	; (92e0 <USB_Handler+0x294>)
    9106:	447b      	add	r3, pc
    9108:	7018      	strb	r0, [r3, #0]
				if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN ==
    910a:	6832      	ldr	r2, [r6, #0]
    910c:	0003      	movs	r3, r0
    910e:	3308      	adds	r3, #8
    9110:	015b      	lsls	r3, r3, #5
    9112:	5c9b      	ldrb	r3, [r3, r2]
    9114:	079b      	lsls	r3, r3, #30
    9116:	0f9b      	lsrs	r3, r3, #30
    9118:	2b01      	cmp	r3, #1
    911a:	d100      	bne.n	911e <USB_Handler+0xd2>
    911c:	e096      	b.n	924c <USB_Handler+0x200>
					pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    911e:	4b71      	ldr	r3, [pc, #452]	; (92e4 <USB_Handler+0x298>)
    9120:	58fb      	ldr	r3, [r7, r3]
    9122:	9300      	str	r3, [sp, #0]
    9124:	0143      	lsls	r3, r0, #5
    9126:	9a00      	ldr	r2, [sp, #0]
    9128:	4694      	mov	ip, r2
    912a:	4463      	add	r3, ip
    912c:	685a      	ldr	r2, [r3, #4]
    912e:	0112      	lsls	r2, r2, #4
    9130:	0c92      	lsrs	r2, r2, #18
    9132:	b290      	uxth	r0, r2
    9134:	496c      	ldr	r1, [pc, #432]	; (92e8 <USB_Handler+0x29c>)
    9136:	4479      	add	r1, pc
    9138:	804a      	strh	r2, [r1, #2]
					pipe_callback_para.required_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    913a:	685a      	ldr	r2, [r3, #4]
    913c:	0492      	lsls	r2, r2, #18
    913e:	0c92      	lsrs	r2, r2, #18
    9140:	808a      	strh	r2, [r1, #4]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
    9142:	685a      	ldr	r2, [r3, #4]
    9144:	4969      	ldr	r1, [pc, #420]	; (92ec <USB_Handler+0x2a0>)
    9146:	400a      	ands	r2, r1
    9148:	605a      	str	r2, [r3, #4]
					if (0 == pipe_callback_para.transfered_size) {
    914a:	2800      	cmp	r0, #0
    914c:	d10c      	bne.n	9168 <USB_Handler+0x11c>
						pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    914e:	4b65      	ldr	r3, [pc, #404]	; (92e4 <USB_Handler+0x298>)
    9150:	58fb      	ldr	r3, [r7, r3]
    9152:	9300      	str	r3, [sp, #0]
    9154:	0163      	lsls	r3, r4, #5
    9156:	9a00      	ldr	r2, [sp, #0]
    9158:	4694      	mov	ip, r2
    915a:	4463      	add	r3, ip
    915c:	685b      	ldr	r3, [r3, #4]
    915e:	049b      	lsls	r3, r3, #18
    9160:	0c9b      	lsrs	r3, r3, #18
    9162:	4a63      	ldr	r2, [pc, #396]	; (92f0 <USB_Handler+0x2a4>)
    9164:	447a      	add	r2, pc
    9166:	8053      	strh	r3, [r2, #2]
				(_usb_instances->host_pipe_callback[pipe_int]
    9168:	4b62      	ldr	r3, [pc, #392]	; (92f4 <USB_Handler+0x2a8>)
    916a:	447b      	add	r3, pc
    916c:	6818      	ldr	r0, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE])(_usb_instances, &pipe_callback_para);
    916e:	1ca3      	adds	r3, r4, #2
    9170:	011b      	lsls	r3, r3, #4
    9172:	18c3      	adds	r3, r0, r3
    9174:	685b      	ldr	r3, [r3, #4]
    9176:	4960      	ldr	r1, [pc, #384]	; (92f8 <USB_Handler+0x2ac>)
    9178:	4479      	add	r1, pc
    917a:	4798      	blx	r3
		if (flags & USB_HOST_PINTFLAG_TRFAIL) {
    917c:	076b      	lsls	r3, r5, #29
    917e:	d510      	bpl.n	91a2 <USB_Handler+0x156>
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    9180:	4b56      	ldr	r3, [pc, #344]	; (92dc <USB_Handler+0x290>)
    9182:	58fa      	ldr	r2, [r7, r3]
    9184:	2301      	movs	r3, #1
    9186:	40a3      	lsls	r3, r4
    9188:	6811      	ldr	r1, [r2, #0]
    918a:	4399      	bics	r1, r3
    918c:	6011      	str	r1, [r2, #0]
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    918e:	4b5b      	ldr	r3, [pc, #364]	; (92fc <USB_Handler+0x2b0>)
    9190:	447b      	add	r3, pc
    9192:	681b      	ldr	r3, [r3, #0]
    9194:	681b      	ldr	r3, [r3, #0]
    9196:	0022      	movs	r2, r4
    9198:	3208      	adds	r2, #8
    919a:	0152      	lsls	r2, r2, #5
    919c:	189b      	adds	r3, r3, r2
    919e:	2204      	movs	r2, #4
    91a0:	71da      	strb	r2, [r3, #7]
		if (flags & USB_HOST_PINTFLAG_PERR) {
    91a2:	072b      	lsls	r3, r5, #28
    91a4:	d516      	bpl.n	91d4 <USB_Handler+0x188>
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    91a6:	4b4d      	ldr	r3, [pc, #308]	; (92dc <USB_Handler+0x290>)
    91a8:	58fa      	ldr	r2, [r7, r3]
    91aa:	2301      	movs	r3, #1
    91ac:	40a3      	lsls	r3, r4
    91ae:	6811      	ldr	r1, [r2, #0]
    91b0:	4399      	bics	r1, r3
    91b2:	6011      	str	r1, [r2, #0]
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    91b4:	4b52      	ldr	r3, [pc, #328]	; (9300 <USB_Handler+0x2b4>)
    91b6:	447b      	add	r3, pc
    91b8:	6818      	ldr	r0, [r3, #0]
    91ba:	0023      	movs	r3, r4
    91bc:	3308      	adds	r3, #8
    91be:	015b      	lsls	r3, r3, #5
    91c0:	6802      	ldr	r2, [r0, #0]
    91c2:	4694      	mov	ip, r2
    91c4:	4463      	add	r3, ip
    91c6:	2208      	movs	r2, #8
    91c8:	71da      	strb	r2, [r3, #7]
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    91ca:	1903      	adds	r3, r0, r4
    91cc:	33ae      	adds	r3, #174	; 0xae
    91ce:	781b      	ldrb	r3, [r3, #0]
    91d0:	079b      	lsls	r3, r3, #30
    91d2:	d451      	bmi.n	9278 <USB_Handler+0x22c>
		if (flags & USB_HOST_PINTFLAG_TXSTP) {
    91d4:	06eb      	lsls	r3, r5, #27
    91d6:	d516      	bpl.n	9206 <USB_Handler+0x1ba>
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    91d8:	4b40      	ldr	r3, [pc, #256]	; (92dc <USB_Handler+0x290>)
    91da:	58fa      	ldr	r2, [r7, r3]
    91dc:	2301      	movs	r3, #1
    91de:	40a3      	lsls	r3, r4
    91e0:	6811      	ldr	r1, [r2, #0]
    91e2:	4399      	bics	r1, r3
    91e4:	6011      	str	r1, [r2, #0]
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    91e6:	4b47      	ldr	r3, [pc, #284]	; (9304 <USB_Handler+0x2b8>)
    91e8:	447b      	add	r3, pc
    91ea:	6818      	ldr	r0, [r3, #0]
    91ec:	0023      	movs	r3, r4
    91ee:	3308      	adds	r3, #8
    91f0:	015b      	lsls	r3, r3, #5
    91f2:	6802      	ldr	r2, [r0, #0]
    91f4:	4694      	mov	ip, r2
    91f6:	4463      	add	r3, ip
    91f8:	2210      	movs	r2, #16
    91fa:	71da      	strb	r2, [r3, #7]
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    91fc:	1903      	adds	r3, r0, r4
    91fe:	33ae      	adds	r3, #174	; 0xae
    9200:	781b      	ldrb	r3, [r3, #0]
    9202:	075b      	lsls	r3, r3, #29
    9204:	d44b      	bmi.n	929e <USB_Handler+0x252>
		if (flags & USB_HOST_PINTFLAG_STALL) {
    9206:	06ab      	lsls	r3, r5, #26
    9208:	d400      	bmi.n	920c <USB_Handler+0x1c0>
    920a:	e0f9      	b.n	9400 <USB_Handler+0x3b4>
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    920c:	4b33      	ldr	r3, [pc, #204]	; (92dc <USB_Handler+0x290>)
    920e:	58fa      	ldr	r2, [r7, r3]
    9210:	2301      	movs	r3, #1
    9212:	40a3      	lsls	r3, r4
    9214:	6811      	ldr	r1, [r2, #0]
    9216:	4399      	bics	r1, r3
    9218:	6011      	str	r1, [r2, #0]
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    921a:	4b3b      	ldr	r3, [pc, #236]	; (9308 <USB_Handler+0x2bc>)
    921c:	447b      	add	r3, pc
    921e:	6818      	ldr	r0, [r3, #0]
    9220:	0023      	movs	r3, r4
    9222:	3308      	adds	r3, #8
    9224:	015b      	lsls	r3, r3, #5
    9226:	6802      	ldr	r2, [r0, #0]
    9228:	4694      	mov	ip, r2
    922a:	4463      	add	r3, ip
    922c:	2220      	movs	r2, #32
    922e:	71da      	strb	r2, [r3, #7]
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    9230:	1903      	adds	r3, r0, r4
    9232:	33ae      	adds	r3, #174	; 0xae
    9234:	781b      	ldrb	r3, [r3, #0]
    9236:	071b      	lsls	r3, r3, #28
    9238:	d400      	bmi.n	923c <USB_Handler+0x1f0>
    923a:	e0e1      	b.n	9400 <USB_Handler+0x3b4>
				pipe_callback_para.pipe_num = pipe_int;
    923c:	4933      	ldr	r1, [pc, #204]	; (930c <USB_Handler+0x2c0>)
    923e:	4479      	add	r1, pc
    9240:	700c      	strb	r4, [r1, #0]
						[USB_HOST_PIPE_CALLBACK_STALL])(_usb_instances, &pipe_callback_para);
    9242:	0124      	lsls	r4, r4, #4
    9244:	1904      	adds	r4, r0, r4
    9246:	6b23      	ldr	r3, [r4, #48]	; 0x30
    9248:	4798      	blx	r3
    924a:	e0d9      	b.n	9400 <USB_Handler+0x3b4>
					pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    924c:	4b25      	ldr	r3, [pc, #148]	; (92e4 <USB_Handler+0x298>)
    924e:	58fb      	ldr	r3, [r7, r3]
    9250:	9300      	str	r3, [sp, #0]
    9252:	0143      	lsls	r3, r0, #5
    9254:	9a00      	ldr	r2, [sp, #0]
    9256:	4694      	mov	ip, r2
    9258:	4463      	add	r3, ip
    925a:	685a      	ldr	r2, [r3, #4]
    925c:	0492      	lsls	r2, r2, #18
    925e:	0c92      	lsrs	r2, r2, #18
    9260:	492b      	ldr	r1, [pc, #172]	; (9310 <USB_Handler+0x2c4>)
    9262:	4479      	add	r1, pc
    9264:	804a      	strh	r2, [r1, #2]
					pipe_callback_para.required_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    9266:	685a      	ldr	r2, [r3, #4]
    9268:	0112      	lsls	r2, r2, #4
    926a:	0c92      	lsrs	r2, r2, #18
    926c:	808a      	strh	r2, [r1, #4]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT = 0;
    926e:	685a      	ldr	r2, [r3, #4]
    9270:	0b92      	lsrs	r2, r2, #14
    9272:	0392      	lsls	r2, r2, #14
    9274:	605a      	str	r2, [r3, #4]
    9276:	e777      	b.n	9168 <USB_Handler+0x11c>
				pipe_callback_para.pipe_num = pipe_int;
    9278:	4926      	ldr	r1, [pc, #152]	; (9314 <USB_Handler+0x2c8>)
    927a:	4479      	add	r1, pc
    927c:	700c      	strb	r4, [r1, #0]
						usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_PIPE.reg & 0x1F;
    927e:	4b19      	ldr	r3, [pc, #100]	; (92e4 <USB_Handler+0x298>)
    9280:	58fb      	ldr	r3, [r7, r3]
    9282:	9300      	str	r3, [sp, #0]
    9284:	0163      	lsls	r3, r4, #5
    9286:	9a00      	ldr	r2, [sp, #0]
    9288:	4694      	mov	ip, r2
    928a:	4463      	add	r3, ip
    928c:	89db      	ldrh	r3, [r3, #14]
    928e:	221f      	movs	r2, #31
    9290:	4013      	ands	r3, r2
				pipe_callback_para.pipe_error_status =
    9292:	704b      	strb	r3, [r1, #1]
						[USB_HOST_PIPE_CALLBACK_ERROR])(_usb_instances, &pipe_callback_para);
    9294:	0123      	lsls	r3, r4, #4
    9296:	18c3      	adds	r3, r0, r3
    9298:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    929a:	4798      	blx	r3
    929c:	e79a      	b.n	91d4 <USB_Handler+0x188>
				pipe_callback_para.pipe_num = pipe_int;
    929e:	4a1e      	ldr	r2, [pc, #120]	; (9318 <USB_Handler+0x2cc>)
    92a0:	447a      	add	r2, pc
    92a2:	7014      	strb	r4, [r2, #0]
				pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    92a4:	4b0f      	ldr	r3, [pc, #60]	; (92e4 <USB_Handler+0x298>)
    92a6:	58fb      	ldr	r3, [r7, r3]
    92a8:	9300      	str	r3, [sp, #0]
    92aa:	0163      	lsls	r3, r4, #5
    92ac:	9900      	ldr	r1, [sp, #0]
    92ae:	468c      	mov	ip, r1
    92b0:	4463      	add	r3, ip
    92b2:	685b      	ldr	r3, [r3, #4]
    92b4:	011b      	lsls	r3, r3, #4
    92b6:	0c9b      	lsrs	r3, r3, #18
    92b8:	8053      	strh	r3, [r2, #2]
						[USB_HOST_PIPE_CALLBACK_SETUP])(_usb_instances, NULL);
    92ba:	0123      	lsls	r3, r4, #4
    92bc:	18c3      	adds	r3, r0, r3
    92be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    92c0:	2100      	movs	r1, #0
    92c2:	4798      	blx	r3
    92c4:	e79f      	b.n	9206 <USB_Handler+0x1ba>
    92c6:	46c0      	nop			; (mov r8, r8)
    92c8:	00000a48 	.word	0x00000a48
    92cc:	1fff706c 	.word	0x1fff706c
    92d0:	000009e0 	.word	0x000009e0
    92d4:	1fff7034 	.word	0x1fff7034
    92d8:	00000090 	.word	0x00000090
    92dc:	00000028 	.word	0x00000028
    92e0:	1fff6fda 	.word	0x1fff6fda
    92e4:	00000008 	.word	0x00000008
    92e8:	1fff6faa 	.word	0x1fff6faa
    92ec:	f0003fff 	.word	0xf0003fff
    92f0:	1fff6f7c 	.word	0x1fff6f7c
    92f4:	1fff6f62 	.word	0x1fff6f62
    92f8:	1fff6f68 	.word	0x1fff6f68
    92fc:	1fff6f3c 	.word	0x1fff6f3c
    9300:	1fff6f16 	.word	0x1fff6f16
    9304:	1fff6ee4 	.word	0x1fff6ee4
    9308:	1fff6eb0 	.word	0x1fff6eb0
    930c:	1fff6ea2 	.word	0x1fff6ea2
    9310:	1fff6e7e 	.word	0x1fff6e7e
    9314:	1fff6e66 	.word	0x1fff6e66
    9318:	1fff6e40 	.word	0x1fff6e40
		flags = _usb_instances->hw->HOST.INTFLAG.reg;
    931c:	8bac      	ldrh	r4, [r5, #28]
    931e:	b2a4      	uxth	r4, r4
		if (flags & USB_HOST_INTFLAG_HSOF) {
    9320:	0763      	lsls	r3, r4, #29
    9322:	d506      	bpl.n	9332 <USB_Handler+0x2e6>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_HSOF;
    9324:	2304      	movs	r3, #4
    9326:	83ab      	strh	r3, [r5, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_SOF)) {
    9328:	33a1      	adds	r3, #161	; 0xa1
    932a:	5cf3      	ldrb	r3, [r6, r3]
    932c:	07db      	lsls	r3, r3, #31
    932e:	d500      	bpl.n	9332 <USB_Handler+0x2e6>
    9330:	e06d      	b.n	940e <USB_Handler+0x3c2>
		if (flags & USB_HOST_INTFLAG_RST) {
    9332:	0723      	lsls	r3, r4, #28
    9334:	d50d      	bpl.n	9352 <USB_Handler+0x306>
			host_pipe_job_busy_status = 0;
    9336:	4bc6      	ldr	r3, [pc, #792]	; (9650 <USB_Handler+0x604>)
    9338:	58fb      	ldr	r3, [r7, r3]
    933a:	2200      	movs	r2, #0
    933c:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_RST;
    933e:	4bc5      	ldr	r3, [pc, #788]	; (9654 <USB_Handler+0x608>)
    9340:	447b      	add	r3, pc
    9342:	6818      	ldr	r0, [r3, #0]
    9344:	2308      	movs	r3, #8
    9346:	6802      	ldr	r2, [r0, #0]
    9348:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_RESET)) {
    934a:	339d      	adds	r3, #157	; 0x9d
    934c:	5cc3      	ldrb	r3, [r0, r3]
    934e:	079b      	lsls	r3, r3, #30
    9350:	d461      	bmi.n	9416 <USB_Handler+0x3ca>
		if (flags & USB_HOST_INTFLAG_UPRSM) {
    9352:	0663      	lsls	r3, r4, #25
    9354:	d509      	bpl.n	936a <USB_Handler+0x31e>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_UPRSM;
    9356:	4bc0      	ldr	r3, [pc, #768]	; (9658 <USB_Handler+0x60c>)
    9358:	447b      	add	r3, pc
    935a:	6818      	ldr	r0, [r3, #0]
    935c:	2340      	movs	r3, #64	; 0x40
    935e:	6802      	ldr	r2, [r0, #0]
    9360:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_UPRSM)) {
    9362:	3365      	adds	r3, #101	; 0x65
    9364:	5cc3      	ldrb	r3, [r0, r3]
    9366:	06db      	lsls	r3, r3, #27
    9368:	d458      	bmi.n	941c <USB_Handler+0x3d0>
		if (flags & USB_HOST_INTFLAG_DNRSM) {
    936a:	06a3      	lsls	r3, r4, #26
    936c:	d509      	bpl.n	9382 <USB_Handler+0x336>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DNRSM;
    936e:	4bbb      	ldr	r3, [pc, #748]	; (965c <USB_Handler+0x610>)
    9370:	447b      	add	r3, pc
    9372:	6818      	ldr	r0, [r3, #0]
    9374:	2320      	movs	r3, #32
    9376:	6802      	ldr	r2, [r0, #0]
    9378:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_DNRSM)) {
    937a:	3385      	adds	r3, #133	; 0x85
    937c:	5cc3      	ldrb	r3, [r0, r3]
    937e:	071b      	lsls	r3, r3, #28
    9380:	d44f      	bmi.n	9422 <USB_Handler+0x3d6>
		if (flags & USB_HOST_INTFLAG_WAKEUP) {
    9382:	06e3      	lsls	r3, r4, #27
    9384:	d509      	bpl.n	939a <USB_Handler+0x34e>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_WAKEUP;
    9386:	4bb6      	ldr	r3, [pc, #728]	; (9660 <USB_Handler+0x614>)
    9388:	447b      	add	r3, pc
    938a:	6818      	ldr	r0, [r3, #0]
    938c:	2310      	movs	r3, #16
    938e:	6802      	ldr	r2, [r0, #0]
    9390:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_WAKEUP)) {
    9392:	3395      	adds	r3, #149	; 0x95
    9394:	5cc3      	ldrb	r3, [r0, r3]
    9396:	075b      	lsls	r3, r3, #29
    9398:	d446      	bmi.n	9428 <USB_Handler+0x3dc>
		if (flags & USB_HOST_INTFLAG_RAMACER) {
    939a:	0623      	lsls	r3, r4, #24
    939c:	d50d      	bpl.n	93ba <USB_Handler+0x36e>
			host_pipe_job_busy_status = 0;
    939e:	4bac      	ldr	r3, [pc, #688]	; (9650 <USB_Handler+0x604>)
    93a0:	58fb      	ldr	r3, [r7, r3]
    93a2:	2200      	movs	r2, #0
    93a4:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_RAMACER;
    93a6:	4baf      	ldr	r3, [pc, #700]	; (9664 <USB_Handler+0x618>)
    93a8:	447b      	add	r3, pc
    93aa:	6818      	ldr	r0, [r3, #0]
    93ac:	2380      	movs	r3, #128	; 0x80
    93ae:	6802      	ldr	r2, [r0, #0]
    93b0:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_RAMACER)) {
    93b2:	3325      	adds	r3, #37	; 0x25
    93b4:	5cc3      	ldrb	r3, [r0, r3]
    93b6:	069b      	lsls	r3, r3, #26
    93b8:	d439      	bmi.n	942e <USB_Handler+0x3e2>
		if (flags & USB_HOST_INTFLAG_DCONN) {
    93ba:	05e3      	lsls	r3, r4, #23
    93bc:	d50e      	bpl.n	93dc <USB_Handler+0x390>
			host_pipe_job_busy_status = 0;
    93be:	4ba4      	ldr	r3, [pc, #656]	; (9650 <USB_Handler+0x604>)
    93c0:	58fb      	ldr	r3, [r7, r3]
    93c2:	2200      	movs	r2, #0
    93c4:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DCONN;
    93c6:	4ba8      	ldr	r3, [pc, #672]	; (9668 <USB_Handler+0x61c>)
    93c8:	447b      	add	r3, pc
    93ca:	6818      	ldr	r0, [r3, #0]
    93cc:	2380      	movs	r3, #128	; 0x80
    93ce:	005b      	lsls	r3, r3, #1
    93d0:	6802      	ldr	r2, [r0, #0]
    93d2:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_CONNECT)) {
    93d4:	3b5b      	subs	r3, #91	; 0x5b
    93d6:	5cc3      	ldrb	r3, [r0, r3]
    93d8:	065b      	lsls	r3, r3, #25
    93da:	d42b      	bmi.n	9434 <USB_Handler+0x3e8>
		if (flags & USB_HOST_INTFLAG_DDISC) {
    93dc:	05a3      	lsls	r3, r4, #22
    93de:	d50f      	bpl.n	9400 <USB_Handler+0x3b4>
			host_pipe_job_busy_status = 0;
    93e0:	4b9b      	ldr	r3, [pc, #620]	; (9650 <USB_Handler+0x604>)
    93e2:	58fb      	ldr	r3, [r7, r3]
    93e4:	2200      	movs	r2, #0
    93e6:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DDISC;
    93e8:	4ba0      	ldr	r3, [pc, #640]	; (966c <USB_Handler+0x620>)
    93ea:	447b      	add	r3, pc
    93ec:	6818      	ldr	r0, [r3, #0]
    93ee:	2380      	movs	r3, #128	; 0x80
    93f0:	009b      	lsls	r3, r3, #2
    93f2:	6802      	ldr	r2, [r0, #0]
    93f4:	8393      	strh	r3, [r2, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_DISCONNECT)) {
    93f6:	3b5c      	subs	r3, #92	; 0x5c
    93f8:	3bff      	subs	r3, #255	; 0xff
    93fa:	5cc3      	ldrb	r3, [r0, r3]
    93fc:	2b7f      	cmp	r3, #127	; 0x7f
    93fe:	d81c      	bhi.n	943a <USB_Handler+0x3ee>
#endif
	} else {
		/*device mode ISR */
		_usb_device_interrupt_handler();
	}
}
    9400:	b003      	add	sp, #12
    9402:	bc3c      	pop	{r2, r3, r4, r5}
    9404:	4690      	mov	r8, r2
    9406:	4699      	mov	r9, r3
    9408:	46a2      	mov	sl, r4
    940a:	46ab      	mov	fp, r5
    940c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				(_usb_instances->host_callback[USB_HOST_CALLBACK_SOF])(_usb_instances);
    940e:	6873      	ldr	r3, [r6, #4]
    9410:	0030      	movs	r0, r6
    9412:	4798      	blx	r3
    9414:	e78d      	b.n	9332 <USB_Handler+0x2e6>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_RESET])(_usb_instances);
    9416:	6883      	ldr	r3, [r0, #8]
    9418:	4798      	blx	r3
    941a:	e79a      	b.n	9352 <USB_Handler+0x306>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_UPRSM])(_usb_instances);
    941c:	6943      	ldr	r3, [r0, #20]
    941e:	4798      	blx	r3
    9420:	e7a3      	b.n	936a <USB_Handler+0x31e>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DNRSM])(_usb_instances);
    9422:	6903      	ldr	r3, [r0, #16]
    9424:	4798      	blx	r3
    9426:	e7ac      	b.n	9382 <USB_Handler+0x336>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_WAKEUP])(_usb_instances);
    9428:	68c3      	ldr	r3, [r0, #12]
    942a:	4798      	blx	r3
    942c:	e7b5      	b.n	939a <USB_Handler+0x34e>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_RAMACER])(_usb_instances);
    942e:	6983      	ldr	r3, [r0, #24]
    9430:	4798      	blx	r3
    9432:	e7c2      	b.n	93ba <USB_Handler+0x36e>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_CONNECT])(_usb_instances);
    9434:	69c3      	ldr	r3, [r0, #28]
    9436:	4798      	blx	r3
    9438:	e7d0      	b.n	93dc <USB_Handler+0x390>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DISCONNECT])(_usb_instances);
    943a:	6a03      	ldr	r3, [r0, #32]
    943c:	4798      	blx	r3
    943e:	e7df      	b.n	9400 <USB_Handler+0x3b4>
				(_usb_instances->device_callback[i])(_usb_instances, &device_callback_lpm_wakeup_enable);
    9440:	4b8b      	ldr	r3, [pc, #556]	; (9670 <USB_Handler+0x624>)
    9442:	447b      	add	r3, pc
    9444:	6818      	ldr	r0, [r3, #0]
    9446:	0023      	movs	r3, r4
    9448:	332e      	adds	r3, #46	; 0x2e
    944a:	009b      	lsls	r3, r3, #2
    944c:	581b      	ldr	r3, [r3, r0]
    944e:	4989      	ldr	r1, [pc, #548]	; (9674 <USB_Handler+0x628>)
    9450:	4479      	add	r1, pc
    9452:	4798      	blx	r3
		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
    9454:	3401      	adds	r4, #1
    9456:	2c07      	cmp	r4, #7
    9458:	d0d2      	beq.n	9400 <USB_Handler+0x3b4>
			if (flags & _usb_device_irq_bits[i]) {
    945a:	0063      	lsls	r3, r4, #1
    945c:	5bdb      	ldrh	r3, [r3, r7]
    945e:	422b      	tst	r3, r5
    9460:	d003      	beq.n	946a <USB_Handler+0x41e>
				_usb_instances->hw->DEVICE.INTFLAG.reg =
    9462:	464a      	mov	r2, r9
    9464:	6812      	ldr	r2, [r2, #0]
    9466:	6812      	ldr	r2, [r2, #0]
    9468:	8393      	strh	r3, [r2, #28]
			if (flags_run & _usb_device_irq_bits[i]) {
    946a:	4233      	tst	r3, r6
    946c:	d0f2      	beq.n	9454 <USB_Handler+0x408>
				if (i == USB_DEVICE_CALLBACK_LPMSUSP) {
    946e:	2c06      	cmp	r4, #6
    9470:	d1e6      	bne.n	9440 <USB_Handler+0x3f4>
							usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].EXTREG.bit.VARIABLE
    9472:	4b81      	ldr	r3, [pc, #516]	; (9678 <USB_Handler+0x62c>)
    9474:	4642      	mov	r2, r8
    9476:	58d3      	ldr	r3, [r2, r3]
    9478:	9300      	str	r3, [sp, #0]
    947a:	891b      	ldrh	r3, [r3, #8]
    947c:	091b      	lsrs	r3, r3, #4
							& USB_LPM_ATTRIBUT_REMOTEWAKE_MASK;
    947e:	4652      	mov	r2, sl
    9480:	4013      	ands	r3, r2
    9482:	4a7e      	ldr	r2, [pc, #504]	; (967c <USB_Handler+0x630>)
    9484:	447a      	add	r2, pc
    9486:	6013      	str	r3, [r2, #0]
    9488:	e7da      	b.n	9440 <USB_Handler+0x3f4>
    948a:	0034      	movs	r4, r6
    948c:	3459      	adds	r4, #89	; 0x59
    948e:	34ff      	adds	r4, #255	; 0xff
	if (0 == ep_inst) {
    9490:	2300      	movs	r3, #0
			if (ep_inst & (1 << i)) {
    9492:	2201      	movs	r2, #1
    9494:	4690      	mov	r8, r2
				if (flags & USB_DEVICE_EPINTFLAG_STALL_Msk) {
    9496:	325f      	adds	r2, #95	; 0x5f
    9498:	4692      	mov	sl, r2
				if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    949a:	3a50      	subs	r2, #80	; 0x50
    949c:	4693      	mov	fp, r2
				if (flags & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
    949e:	46b9      	mov	r9, r7
    94a0:	4667      	mov	r7, ip
    94a2:	46b4      	mov	ip, r6
    94a4:	002e      	movs	r6, r5
    94a6:	e100      	b.n	96aa <USB_Handler+0x65e>
    94a8:	46a9      	mov	r9, r5
    94aa:	0035      	movs	r5, r6
    94ac:	4666      	mov	r6, ip
    94ae:	015b      	lsls	r3, r3, #5
    94b0:	18ed      	adds	r5, r5, r3
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL1) {
    94b2:	2308      	movs	r3, #8
    94b4:	33ff      	adds	r3, #255	; 0xff
    94b6:	5ceb      	ldrb	r3, [r5, r3]
    94b8:	065b      	lsls	r3, r3, #25
    94ba:	d518      	bpl.n	94ee <USB_Handler+0x4a2>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL1;
    94bc:	2240      	movs	r2, #64	; 0x40
    94be:	2308      	movs	r3, #8
    94c0:	33ff      	adds	r3, #255	; 0xff
    94c2:	54ea      	strb	r2, [r5, r3]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
    94c4:	3b88      	subs	r3, #136	; 0x88
    94c6:	3bff      	subs	r3, #255	; 0xff
    94c8:	464a      	mov	r2, r9
    94ca:	4313      	orrs	r3, r2
    94cc:	4a6c      	ldr	r2, [pc, #432]	; (9680 <USB_Handler+0x634>)
    94ce:	447a      	add	r2, pc
    94d0:	7193      	strb	r3, [r2, #6]
					if (flags_run & USB_DEVICE_EPINTFLAG_STALL_Msk) {
    94d2:	2360      	movs	r3, #96	; 0x60
    94d4:	420b      	tst	r3, r1
    94d6:	d100      	bne.n	94da <USB_Handler+0x48e>
    94d8:	e792      	b.n	9400 <USB_Handler+0x3b4>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_STALL])(_usb_instances,&ep_callback_para);
    94da:	9b00      	ldr	r3, [sp, #0]
    94dc:	011b      	lsls	r3, r3, #4
    94de:	18f3      	adds	r3, r6, r3
    94e0:	33e0      	adds	r3, #224	; 0xe0
    94e2:	681b      	ldr	r3, [r3, #0]
    94e4:	4967      	ldr	r1, [pc, #412]	; (9684 <USB_Handler+0x638>)
    94e6:	4479      	add	r1, pc
    94e8:	0030      	movs	r0, r6
    94ea:	4798      	blx	r3
    94ec:	e788      	b.n	9400 <USB_Handler+0x3b4>
					} else if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL0) {
    94ee:	2308      	movs	r3, #8
    94f0:	33ff      	adds	r3, #255	; 0xff
    94f2:	5ceb      	ldrb	r3, [r5, r3]
    94f4:	069b      	lsls	r3, r3, #26
    94f6:	d5ec      	bpl.n	94d2 <USB_Handler+0x486>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL0;
    94f8:	2220      	movs	r2, #32
    94fa:	2308      	movs	r3, #8
    94fc:	33ff      	adds	r3, #255	; 0xff
    94fe:	54ea      	strb	r2, [r5, r3]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
    9500:	4b61      	ldr	r3, [pc, #388]	; (9688 <USB_Handler+0x63c>)
    9502:	447b      	add	r3, pc
    9504:	464a      	mov	r2, r9
    9506:	719a      	strb	r2, [r3, #6]
    9508:	e7e3      	b.n	94d2 <USB_Handler+0x486>
    950a:	0035      	movs	r5, r6
    950c:	4666      	mov	r6, ip
    950e:	464f      	mov	r7, r9
					_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP;
    9510:	9a00      	ldr	r2, [sp, #0]
    9512:	0013      	movs	r3, r2
    9514:	3308      	adds	r3, #8
    9516:	015b      	lsls	r3, r3, #5
    9518:	18ed      	adds	r5, r5, r3
    951a:	2310      	movs	r3, #16
    951c:	71eb      	strb	r3, [r5, #7]
					if(_usb_instances->device_endpoint_enabled_callback_mask[i] & _usb_endpoint_irq_bits[USB_DEVICE_ENDPOINT_CALLBACK_RXSTP]) {
    951e:	18b3      	adds	r3, r6, r2
    9520:	3361      	adds	r3, #97	; 0x61
    9522:	33ff      	adds	r3, #255	; 0xff
    9524:	781b      	ldrb	r3, [r3, #0]
    9526:	06db      	lsls	r3, r3, #27
    9528:	d400      	bmi.n	952c <USB_Handler+0x4e0>
    952a:	e769      	b.n	9400 <USB_Handler+0x3b4>
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
    952c:	4b52      	ldr	r3, [pc, #328]	; (9678 <USB_Handler+0x62c>)
    952e:	58fb      	ldr	r3, [r7, r3]
    9530:	9301      	str	r3, [sp, #4]
    9532:	0153      	lsls	r3, r2, #5
    9534:	9901      	ldr	r1, [sp, #4]
    9536:	468c      	mov	ip, r1
    9538:	4463      	add	r3, ip
    953a:	685b      	ldr	r3, [r3, #4]
    953c:	049b      	lsls	r3, r3, #18
    953e:	0c9b      	lsrs	r3, r3, #18
    9540:	4952      	ldr	r1, [pc, #328]	; (968c <USB_Handler+0x640>)
    9542:	4479      	add	r1, pc
    9544:	800b      	strh	r3, [r1, #0]
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_RXSTP])(_usb_instances,&ep_callback_para);
    9546:	0113      	lsls	r3, r2, #4
    9548:	18f3      	adds	r3, r6, r3
    954a:	33dc      	adds	r3, #220	; 0xdc
    954c:	681b      	ldr	r3, [r3, #0]
    954e:	0030      	movs	r0, r6
    9550:	4798      	blx	r3
    9552:	e755      	b.n	9400 <USB_Handler+0x3b4>
    9554:	464f      	mov	r7, r9
    9556:	46a9      	mov	r9, r5
    9558:	0035      	movs	r5, r6
    955a:	4666      	mov	r6, ip
    955c:	015b      	lsls	r3, r3, #5
    955e:	18ed      	adds	r5, r5, r3
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT1) {
    9560:	2308      	movs	r3, #8
    9562:	33ff      	adds	r3, #255	; 0xff
    9564:	5ceb      	ldrb	r3, [r5, r3]
    9566:	079b      	lsls	r3, r3, #30
    9568:	d524      	bpl.n	95b4 <USB_Handler+0x568>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
    956a:	2202      	movs	r2, #2
    956c:	2308      	movs	r3, #8
    956e:	33ff      	adds	r3, #255	; 0xff
    9570:	54ea      	strb	r2, [r5, r3]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
    9572:	4a47      	ldr	r2, [pc, #284]	; (9690 <USB_Handler+0x644>)
    9574:	447a      	add	r2, pc
    9576:	3b88      	subs	r3, #136	; 0x88
    9578:	3bff      	subs	r3, #255	; 0xff
    957a:	4648      	mov	r0, r9
    957c:	4303      	orrs	r3, r0
    957e:	7193      	strb	r3, [r2, #6]
						ep_callback_para.sent_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT);
    9580:	4b3d      	ldr	r3, [pc, #244]	; (9678 <USB_Handler+0x62c>)
    9582:	58fb      	ldr	r3, [r7, r3]
    9584:	9301      	str	r3, [sp, #4]
    9586:	9b00      	ldr	r3, [sp, #0]
    9588:	015b      	lsls	r3, r3, #5
    958a:	9801      	ldr	r0, [sp, #4]
    958c:	4684      	mov	ip, r0
    958e:	4463      	add	r3, ip
    9590:	3310      	adds	r3, #16
    9592:	685b      	ldr	r3, [r3, #4]
    9594:	049b      	lsls	r3, r3, #18
    9596:	0c9b      	lsrs	r3, r3, #18
    9598:	8053      	strh	r3, [r2, #2]
					if(flags_run & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
    959a:	078b      	lsls	r3, r1, #30
    959c:	d100      	bne.n	95a0 <USB_Handler+0x554>
    959e:	e72f      	b.n	9400 <USB_Handler+0x3b4>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRCPT])(_usb_instances,&ep_callback_para);
    95a0:	9b00      	ldr	r3, [sp, #0]
    95a2:	330d      	adds	r3, #13
    95a4:	011b      	lsls	r3, r3, #4
    95a6:	18f3      	adds	r3, r6, r3
    95a8:	685b      	ldr	r3, [r3, #4]
    95aa:	493a      	ldr	r1, [pc, #232]	; (9694 <USB_Handler+0x648>)
    95ac:	4479      	add	r1, pc
    95ae:	0030      	movs	r0, r6
    95b0:	4798      	blx	r3
    95b2:	e725      	b.n	9400 <USB_Handler+0x3b4>
					} else if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
    95b4:	2308      	movs	r3, #8
    95b6:	33ff      	adds	r3, #255	; 0xff
    95b8:	5ceb      	ldrb	r3, [r5, r3]
    95ba:	07db      	lsls	r3, r3, #31
    95bc:	d5ed      	bpl.n	959a <USB_Handler+0x54e>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;
    95be:	2201      	movs	r2, #1
    95c0:	2308      	movs	r3, #8
    95c2:	33ff      	adds	r3, #255	; 0xff
    95c4:	54ea      	strb	r2, [r5, r3]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
    95c6:	4834      	ldr	r0, [pc, #208]	; (9698 <USB_Handler+0x64c>)
    95c8:	4478      	add	r0, pc
    95ca:	464b      	mov	r3, r9
    95cc:	7183      	strb	r3, [r0, #6]
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
    95ce:	4b2a      	ldr	r3, [pc, #168]	; (9678 <USB_Handler+0x62c>)
    95d0:	58fb      	ldr	r3, [r7, r3]
    95d2:	9301      	str	r3, [sp, #4]
    95d4:	9b00      	ldr	r3, [sp, #0]
    95d6:	015a      	lsls	r2, r3, #5
    95d8:	9b01      	ldr	r3, [sp, #4]
    95da:	469c      	mov	ip, r3
    95dc:	4462      	add	r2, ip
    95de:	6853      	ldr	r3, [r2, #4]
    95e0:	049b      	lsls	r3, r3, #18
    95e2:	0c9b      	lsrs	r3, r3, #18
    95e4:	8003      	strh	r3, [r0, #0]
						ep_callback_para.out_buffer_size = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE);
    95e6:	6853      	ldr	r3, [r2, #4]
    95e8:	011b      	lsls	r3, r3, #4
    95ea:	0c9b      	lsrs	r3, r3, #18
    95ec:	8083      	strh	r3, [r0, #4]
    95ee:	e7d4      	b.n	959a <USB_Handler+0x54e>
					} else if(_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    95f0:	2308      	movs	r3, #8
    95f2:	33ff      	adds	r3, #255	; 0xff
    95f4:	5ceb      	ldrb	r3, [r5, r3]
    95f6:	075b      	lsls	r3, r3, #29
    95f8:	d400      	bmi.n	95fc <USB_Handler+0x5b0>
    95fa:	e0ad      	b.n	9758 <USB_Handler+0x70c>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRFAIL0;
    95fc:	2204      	movs	r2, #4
    95fe:	2308      	movs	r3, #8
    9600:	33ff      	adds	r3, #255	; 0xff
    9602:	54ea      	strb	r2, [r5, r3]
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
    9604:	4b1c      	ldr	r3, [pc, #112]	; (9678 <USB_Handler+0x62c>)
    9606:	58fb      	ldr	r3, [r7, r3]
    9608:	9301      	str	r3, [sp, #4]
    960a:	9a00      	ldr	r2, [sp, #0]
    960c:	0153      	lsls	r3, r2, #5
    960e:	9801      	ldr	r0, [sp, #4]
    9610:	4684      	mov	ip, r0
    9612:	4463      	add	r3, ip
    9614:	7a9b      	ldrb	r3, [r3, #10]
    9616:	079b      	lsls	r3, r3, #30
    9618:	d50a      	bpl.n	9630 <USB_Handler+0x5e4>
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
    961a:	4b17      	ldr	r3, [pc, #92]	; (9678 <USB_Handler+0x62c>)
    961c:	58fb      	ldr	r3, [r7, r3]
    961e:	9301      	str	r3, [sp, #4]
    9620:	0153      	lsls	r3, r2, #5
    9622:	9a01      	ldr	r2, [sp, #4]
    9624:	4694      	mov	ip, r2
    9626:	4463      	add	r3, ip
    9628:	7a9a      	ldrb	r2, [r3, #10]
    962a:	2002      	movs	r0, #2
    962c:	4382      	bics	r2, r0
    962e:	729a      	strb	r2, [r3, #10]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
    9630:	4b1a      	ldr	r3, [pc, #104]	; (969c <USB_Handler+0x650>)
    9632:	447b      	add	r3, pc
    9634:	464a      	mov	r2, r9
    9636:	719a      	strb	r2, [r3, #6]
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
    9638:	9b00      	ldr	r3, [sp, #0]
    963a:	3308      	adds	r3, #8
    963c:	015b      	lsls	r3, r3, #5
    963e:	6832      	ldr	r2, [r6, #0]
    9640:	4694      	mov	ip, r2
    9642:	4463      	add	r3, ip
    9644:	79db      	ldrb	r3, [r3, #7]
    9646:	07db      	lsls	r3, r3, #31
    9648:	d400      	bmi.n	964c <USB_Handler+0x600>
    964a:	e085      	b.n	9758 <USB_Handler+0x70c>
    964c:	e6d8      	b.n	9400 <USB_Handler+0x3b4>
    964e:	46c0      	nop			; (mov r8, r8)
    9650:	00000028 	.word	0x00000028
    9654:	1fff6d8c 	.word	0x1fff6d8c
    9658:	1fff6d74 	.word	0x1fff6d74
    965c:	1fff6d5c 	.word	0x1fff6d5c
    9660:	1fff6d44 	.word	0x1fff6d44
    9664:	1fff6d24 	.word	0x1fff6d24
    9668:	1fff6d04 	.word	0x1fff6d04
    966c:	1fff6ce2 	.word	0x1fff6ce2
    9670:	1fff6c8a 	.word	0x1fff6c8a
    9674:	1fff6c80 	.word	0x1fff6c80
    9678:	00000008 	.word	0x00000008
    967c:	1fff6c4c 	.word	0x1fff6c4c
    9680:	1fff6c06 	.word	0x1fff6c06
    9684:	1fff6bee 	.word	0x1fff6bee
    9688:	1fff6bd2 	.word	0x1fff6bd2
    968c:	1fff6b92 	.word	0x1fff6b92
    9690:	1fff6b60 	.word	0x1fff6b60
    9694:	1fff6b28 	.word	0x1fff6b28
    9698:	1fff6b0c 	.word	0x1fff6b0c
    969c:	1fff6aa2 	.word	0x1fff6aa2
    96a0:	3301      	adds	r3, #1
    96a2:	3401      	adds	r4, #1
		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {
    96a4:	2b08      	cmp	r3, #8
    96a6:	d100      	bne.n	96aa <USB_Handler+0x65e>
    96a8:	e6aa      	b.n	9400 <USB_Handler+0x3b4>
    96aa:	b2dd      	uxtb	r5, r3
			if (ep_inst & (1 << i)) {
    96ac:	9300      	str	r3, [sp, #0]
    96ae:	003a      	movs	r2, r7
    96b0:	411a      	asrs	r2, r3
    96b2:	4641      	mov	r1, r8
    96b4:	4211      	tst	r1, r2
    96b6:	d0f3      	beq.n	96a0 <USB_Handler+0x654>
				flags = _usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg;
    96b8:	001a      	movs	r2, r3
    96ba:	3208      	adds	r2, #8
    96bc:	0152      	lsls	r2, r2, #5
    96be:	18b2      	adds	r2, r6, r2
    96c0:	79d2      	ldrb	r2, [r2, #7]
    96c2:	b2d2      	uxtb	r2, r2
    96c4:	7a21      	ldrb	r1, [r4, #8]
    96c6:	4011      	ands	r1, r2
    96c8:	7820      	ldrb	r0, [r4, #0]
    96ca:	4001      	ands	r1, r0
				if (flags & USB_DEVICE_EPINTFLAG_STALL_Msk) {
    96cc:	4650      	mov	r0, sl
    96ce:	4210      	tst	r0, r2
    96d0:	d000      	beq.n	96d4 <USB_Handler+0x688>
    96d2:	e6e9      	b.n	94a8 <USB_Handler+0x45c>
				if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    96d4:	4658      	mov	r0, fp
    96d6:	4210      	tst	r0, r2
    96d8:	d000      	beq.n	96dc <USB_Handler+0x690>
    96da:	e716      	b.n	950a <USB_Handler+0x4be>
				if (flags & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
    96dc:	2003      	movs	r0, #3
    96de:	4210      	tst	r0, r2
    96e0:	d000      	beq.n	96e4 <USB_Handler+0x698>
    96e2:	e737      	b.n	9554 <USB_Handler+0x508>
				if (flags & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
    96e4:	200c      	movs	r0, #12
    96e6:	4210      	tst	r0, r2
    96e8:	d0da      	beq.n	96a0 <USB_Handler+0x654>
    96ea:	464f      	mov	r7, r9
    96ec:	46a9      	mov	r9, r5
    96ee:	0035      	movs	r5, r6
    96f0:	4666      	mov	r6, ip
    96f2:	015b      	lsls	r3, r3, #5
    96f4:	18ed      	adds	r5, r5, r3
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    96f6:	2308      	movs	r3, #8
    96f8:	33ff      	adds	r3, #255	; 0xff
    96fa:	5ceb      	ldrb	r3, [r5, r3]
    96fc:	071b      	lsls	r3, r3, #28
    96fe:	d400      	bmi.n	9702 <USB_Handler+0x6b6>
    9700:	e776      	b.n	95f0 <USB_Handler+0x5a4>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRFAIL1;
    9702:	2208      	movs	r2, #8
    9704:	2308      	movs	r3, #8
    9706:	33ff      	adds	r3, #255	; 0xff
    9708:	54ea      	strb	r2, [r5, r3]
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
    970a:	4b1a      	ldr	r3, [pc, #104]	; (9774 <USB_Handler+0x728>)
    970c:	58fb      	ldr	r3, [r7, r3]
    970e:	9301      	str	r3, [sp, #4]
    9710:	9a00      	ldr	r2, [sp, #0]
    9712:	0153      	lsls	r3, r2, #5
    9714:	9801      	ldr	r0, [sp, #4]
    9716:	4684      	mov	ip, r0
    9718:	4463      	add	r3, ip
    971a:	7e9b      	ldrb	r3, [r3, #26]
    971c:	079b      	lsls	r3, r3, #30
    971e:	d50a      	bpl.n	9736 <USB_Handler+0x6ea>
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
    9720:	4b14      	ldr	r3, [pc, #80]	; (9774 <USB_Handler+0x728>)
    9722:	58fb      	ldr	r3, [r7, r3]
    9724:	9301      	str	r3, [sp, #4]
    9726:	0153      	lsls	r3, r2, #5
    9728:	9a01      	ldr	r2, [sp, #4]
    972a:	4694      	mov	ip, r2
    972c:	4463      	add	r3, ip
    972e:	7e9a      	ldrb	r2, [r3, #26]
    9730:	2002      	movs	r0, #2
    9732:	4382      	bics	r2, r0
    9734:	769a      	strb	r2, [r3, #26]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
    9736:	2380      	movs	r3, #128	; 0x80
    9738:	425b      	negs	r3, r3
    973a:	464a      	mov	r2, r9
    973c:	4313      	orrs	r3, r2
    973e:	4a0e      	ldr	r2, [pc, #56]	; (9778 <USB_Handler+0x72c>)
    9740:	447a      	add	r2, pc
    9742:	7193      	strb	r3, [r2, #6]
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT1) {
    9744:	9b00      	ldr	r3, [sp, #0]
    9746:	3308      	adds	r3, #8
    9748:	015b      	lsls	r3, r3, #5
    974a:	6832      	ldr	r2, [r6, #0]
    974c:	4694      	mov	ip, r2
    974e:	4463      	add	r3, ip
    9750:	79db      	ldrb	r3, [r3, #7]
    9752:	079b      	lsls	r3, r3, #30
    9754:	d500      	bpl.n	9758 <USB_Handler+0x70c>
    9756:	e653      	b.n	9400 <USB_Handler+0x3b4>
					if(flags_run & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
    9758:	230c      	movs	r3, #12
    975a:	420b      	tst	r3, r1
    975c:	d100      	bne.n	9760 <USB_Handler+0x714>
    975e:	e64f      	b.n	9400 <USB_Handler+0x3b4>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL])(_usb_instances,&ep_callback_para);
    9760:	9b00      	ldr	r3, [sp, #0]
    9762:	011b      	lsls	r3, r3, #4
    9764:	18f3      	adds	r3, r6, r3
    9766:	33d8      	adds	r3, #216	; 0xd8
    9768:	681b      	ldr	r3, [r3, #0]
    976a:	4904      	ldr	r1, [pc, #16]	; (977c <USB_Handler+0x730>)
    976c:	4479      	add	r1, pc
    976e:	0030      	movs	r0, r6
    9770:	4798      	blx	r3
    9772:	e645      	b.n	9400 <USB_Handler+0x3b4>
    9774:	00000008 	.word	0x00000008
    9778:	1fff6994 	.word	0x1fff6994
    977c:	1fff6968 	.word	0x1fff6968

00009780 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    9780:	e7fe      	b.n	9780 <Dummy_Handler>
	...

00009784 <Reset_Handler>:
{
    9784:	b5f0      	push	{r4, r5, r6, r7, lr}
    9786:	b083      	sub	sp, #12
    9788:	4c40      	ldr	r4, [pc, #256]	; (988c <Reset_Handler+0x108>)
    978a:	447c      	add	r4, pc
        if (pSrc != pDest) {
    978c:	4b40      	ldr	r3, [pc, #256]	; (9890 <Reset_Handler+0x10c>)
    978e:	58e3      	ldr	r3, [r4, r3]
    9790:	9300      	str	r3, [sp, #0]
    9792:	4b40      	ldr	r3, [pc, #256]	; (9894 <Reset_Handler+0x110>)
    9794:	58e3      	ldr	r3, [r4, r3]
    9796:	9301      	str	r3, [sp, #4]
    9798:	9b00      	ldr	r3, [sp, #0]
    979a:	9a01      	ldr	r2, [sp, #4]
    979c:	4293      	cmp	r3, r2
    979e:	d022      	beq.n	97e6 <Reset_Handler+0x62>
                for (; pDest < &_erelocate;) {
    97a0:	4b3c      	ldr	r3, [pc, #240]	; (9894 <Reset_Handler+0x110>)
    97a2:	58e3      	ldr	r3, [r4, r3]
    97a4:	9300      	str	r3, [sp, #0]
    97a6:	4b3c      	ldr	r3, [pc, #240]	; (9898 <Reset_Handler+0x114>)
    97a8:	58e3      	ldr	r3, [r4, r3]
    97aa:	9301      	str	r3, [sp, #4]
    97ac:	9b00      	ldr	r3, [sp, #0]
    97ae:	9a01      	ldr	r2, [sp, #4]
    97b0:	4293      	cmp	r3, r2
    97b2:	d218      	bcs.n	97e6 <Reset_Handler+0x62>
    97b4:	4b38      	ldr	r3, [pc, #224]	; (9898 <Reset_Handler+0x114>)
    97b6:	58e3      	ldr	r3, [r4, r3]
    97b8:	9300      	str	r3, [sp, #0]
    97ba:	4b36      	ldr	r3, [pc, #216]	; (9894 <Reset_Handler+0x110>)
    97bc:	58e3      	ldr	r3, [r4, r3]
    97be:	9301      	str	r3, [sp, #4]
    97c0:	43db      	mvns	r3, r3
    97c2:	9a00      	ldr	r2, [sp, #0]
    97c4:	4694      	mov	ip, r2
    97c6:	4463      	add	r3, ip
    97c8:	089b      	lsrs	r3, r3, #2
    97ca:	3301      	adds	r3, #1
    97cc:	009b      	lsls	r3, r3, #2
    97ce:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    97d0:	4930      	ldr	r1, [pc, #192]	; (9894 <Reset_Handler+0x110>)
    97d2:	5861      	ldr	r1, [r4, r1]
    97d4:	9100      	str	r1, [sp, #0]
    97d6:	492e      	ldr	r1, [pc, #184]	; (9890 <Reset_Handler+0x10c>)
    97d8:	5861      	ldr	r1, [r4, r1]
    97da:	9800      	ldr	r0, [sp, #0]
    97dc:	588d      	ldr	r5, [r1, r2]
    97de:	5085      	str	r5, [r0, r2]
    97e0:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    97e2:	429a      	cmp	r2, r3
    97e4:	d1f9      	bne.n	97da <Reset_Handler+0x56>
        for (pDest = &_szero; pDest < &_ezero;) {
    97e6:	4b2d      	ldr	r3, [pc, #180]	; (989c <Reset_Handler+0x118>)
    97e8:	58e3      	ldr	r3, [r4, r3]
    97ea:	9300      	str	r3, [sp, #0]
    97ec:	4b2c      	ldr	r3, [pc, #176]	; (98a0 <Reset_Handler+0x11c>)
    97ee:	58e3      	ldr	r3, [r4, r3]
    97f0:	9301      	str	r3, [sp, #4]
    97f2:	9b00      	ldr	r3, [sp, #0]
    97f4:	9a01      	ldr	r2, [sp, #4]
    97f6:	4293      	cmp	r3, r2
    97f8:	d210      	bcs.n	981c <Reset_Handler+0x98>
    97fa:	4b28      	ldr	r3, [pc, #160]	; (989c <Reset_Handler+0x118>)
    97fc:	58e2      	ldr	r2, [r4, r3]
    97fe:	4b28      	ldr	r3, [pc, #160]	; (98a0 <Reset_Handler+0x11c>)
    9800:	58e3      	ldr	r3, [r4, r3]
    9802:	9300      	str	r3, [sp, #0]
    9804:	43d3      	mvns	r3, r2
    9806:	9900      	ldr	r1, [sp, #0]
    9808:	468c      	mov	ip, r1
    980a:	4463      	add	r3, ip
    980c:	2103      	movs	r1, #3
    980e:	438b      	bics	r3, r1
    9810:	3304      	adds	r3, #4
    9812:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
    9814:	2100      	movs	r1, #0
    9816:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
    9818:	4293      	cmp	r3, r2
    981a:	d1fc      	bne.n	9816 <Reset_Handler+0x92>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    981c:	4b21      	ldr	r3, [pc, #132]	; (98a4 <Reset_Handler+0x120>)
    981e:	58e3      	ldr	r3, [r4, r3]
    9820:	9300      	str	r3, [sp, #0]
    9822:	23ff      	movs	r3, #255	; 0xff
    9824:	9a00      	ldr	r2, [sp, #0]
    9826:	439a      	bics	r2, r3
    9828:	0013      	movs	r3, r2
    982a:	4a1f      	ldr	r2, [pc, #124]	; (98a8 <Reset_Handler+0x124>)
    982c:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    982e:	2102      	movs	r1, #2
    9830:	2390      	movs	r3, #144	; 0x90
    9832:	005b      	lsls	r3, r3, #1
    9834:	4a1d      	ldr	r2, [pc, #116]	; (98ac <Reset_Handler+0x128>)
    9836:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    9838:	491d      	ldr	r1, [pc, #116]	; (98b0 <Reset_Handler+0x12c>)
    983a:	78cb      	ldrb	r3, [r1, #3]
    983c:	2603      	movs	r6, #3
    983e:	43b3      	bics	r3, r6
    9840:	2502      	movs	r5, #2
    9842:	432b      	orrs	r3, r5
    9844:	70cb      	strb	r3, [r1, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    9846:	78cb      	ldrb	r3, [r1, #3]
    9848:	270c      	movs	r7, #12
    984a:	43bb      	bics	r3, r7
    984c:	2208      	movs	r2, #8
    984e:	4313      	orrs	r3, r2
    9850:	70cb      	strb	r3, [r1, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    9852:	4b18      	ldr	r3, [pc, #96]	; (98b4 <Reset_Handler+0x130>)
    9854:	7b98      	ldrb	r0, [r3, #14]
    9856:	2130      	movs	r1, #48	; 0x30
    9858:	4388      	bics	r0, r1
    985a:	2120      	movs	r1, #32
    985c:	4308      	orrs	r0, r1
    985e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    9860:	7b99      	ldrb	r1, [r3, #14]
    9862:	43b9      	bics	r1, r7
    9864:	4311      	orrs	r1, r2
    9866:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    9868:	7b9a      	ldrb	r2, [r3, #14]
    986a:	43b2      	bics	r2, r6
    986c:	432a      	orrs	r2, r5
    986e:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    9870:	4a11      	ldr	r2, [pc, #68]	; (98b8 <Reset_Handler+0x134>)
    9872:	6853      	ldr	r3, [r2, #4]
    9874:	2180      	movs	r1, #128	; 0x80
    9876:	430b      	orrs	r3, r1
    9878:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    987a:	4b10      	ldr	r3, [pc, #64]	; (98bc <Reset_Handler+0x138>)
    987c:	58e3      	ldr	r3, [r4, r3]
    987e:	9300      	str	r3, [sp, #0]
    9880:	4798      	blx	r3
        main();
    9882:	4b0f      	ldr	r3, [pc, #60]	; (98c0 <Reset_Handler+0x13c>)
    9884:	58e3      	ldr	r3, [r4, r3]
    9886:	9300      	str	r3, [sp, #0]
    9888:	4798      	blx	r3
    988a:	e7fe      	b.n	988a <Reset_Handler+0x106>
    988c:	0000031a 	.word	0x0000031a
    9890:	0000001c 	.word	0x0000001c
    9894:	00000024 	.word	0x00000024
    9898:	00000094 	.word	0x00000094
    989c:	00000020 	.word	0x00000020
    98a0:	00000070 	.word	0x00000070
    98a4:	00000014 	.word	0x00000014
    98a8:	e000ed00 	.word	0xe000ed00
    98ac:	41007000 	.word	0x41007000
    98b0:	41005000 	.word	0x41005000
    98b4:	41004800 	.word	0x41004800
    98b8:	41004000 	.word	0x41004000
    98bc:	00000044 	.word	0x00000044
    98c0:	00000068 	.word	0x00000068

000098c4 <__gnu_thumb1_case_uqi>:
    98c4:	b402      	push	{r1}
    98c6:	4671      	mov	r1, lr
    98c8:	0849      	lsrs	r1, r1, #1
    98ca:	0049      	lsls	r1, r1, #1
    98cc:	5c09      	ldrb	r1, [r1, r0]
    98ce:	0049      	lsls	r1, r1, #1
    98d0:	448e      	add	lr, r1
    98d2:	bc02      	pop	{r1}
    98d4:	4770      	bx	lr
    98d6:	46c0      	nop			; (mov r8, r8)

000098d8 <__udivsi3>:
    98d8:	2200      	movs	r2, #0
    98da:	0843      	lsrs	r3, r0, #1
    98dc:	428b      	cmp	r3, r1
    98de:	d374      	bcc.n	99ca <__udivsi3+0xf2>
    98e0:	0903      	lsrs	r3, r0, #4
    98e2:	428b      	cmp	r3, r1
    98e4:	d35f      	bcc.n	99a6 <__udivsi3+0xce>
    98e6:	0a03      	lsrs	r3, r0, #8
    98e8:	428b      	cmp	r3, r1
    98ea:	d344      	bcc.n	9976 <__udivsi3+0x9e>
    98ec:	0b03      	lsrs	r3, r0, #12
    98ee:	428b      	cmp	r3, r1
    98f0:	d328      	bcc.n	9944 <__udivsi3+0x6c>
    98f2:	0c03      	lsrs	r3, r0, #16
    98f4:	428b      	cmp	r3, r1
    98f6:	d30d      	bcc.n	9914 <__udivsi3+0x3c>
    98f8:	22ff      	movs	r2, #255	; 0xff
    98fa:	0209      	lsls	r1, r1, #8
    98fc:	ba12      	rev	r2, r2
    98fe:	0c03      	lsrs	r3, r0, #16
    9900:	428b      	cmp	r3, r1
    9902:	d302      	bcc.n	990a <__udivsi3+0x32>
    9904:	1212      	asrs	r2, r2, #8
    9906:	0209      	lsls	r1, r1, #8
    9908:	d065      	beq.n	99d6 <__udivsi3+0xfe>
    990a:	0b03      	lsrs	r3, r0, #12
    990c:	428b      	cmp	r3, r1
    990e:	d319      	bcc.n	9944 <__udivsi3+0x6c>
    9910:	e000      	b.n	9914 <__udivsi3+0x3c>
    9912:	0a09      	lsrs	r1, r1, #8
    9914:	0bc3      	lsrs	r3, r0, #15
    9916:	428b      	cmp	r3, r1
    9918:	d301      	bcc.n	991e <__udivsi3+0x46>
    991a:	03cb      	lsls	r3, r1, #15
    991c:	1ac0      	subs	r0, r0, r3
    991e:	4152      	adcs	r2, r2
    9920:	0b83      	lsrs	r3, r0, #14
    9922:	428b      	cmp	r3, r1
    9924:	d301      	bcc.n	992a <__udivsi3+0x52>
    9926:	038b      	lsls	r3, r1, #14
    9928:	1ac0      	subs	r0, r0, r3
    992a:	4152      	adcs	r2, r2
    992c:	0b43      	lsrs	r3, r0, #13
    992e:	428b      	cmp	r3, r1
    9930:	d301      	bcc.n	9936 <__udivsi3+0x5e>
    9932:	034b      	lsls	r3, r1, #13
    9934:	1ac0      	subs	r0, r0, r3
    9936:	4152      	adcs	r2, r2
    9938:	0b03      	lsrs	r3, r0, #12
    993a:	428b      	cmp	r3, r1
    993c:	d301      	bcc.n	9942 <__udivsi3+0x6a>
    993e:	030b      	lsls	r3, r1, #12
    9940:	1ac0      	subs	r0, r0, r3
    9942:	4152      	adcs	r2, r2
    9944:	0ac3      	lsrs	r3, r0, #11
    9946:	428b      	cmp	r3, r1
    9948:	d301      	bcc.n	994e <__udivsi3+0x76>
    994a:	02cb      	lsls	r3, r1, #11
    994c:	1ac0      	subs	r0, r0, r3
    994e:	4152      	adcs	r2, r2
    9950:	0a83      	lsrs	r3, r0, #10
    9952:	428b      	cmp	r3, r1
    9954:	d301      	bcc.n	995a <__udivsi3+0x82>
    9956:	028b      	lsls	r3, r1, #10
    9958:	1ac0      	subs	r0, r0, r3
    995a:	4152      	adcs	r2, r2
    995c:	0a43      	lsrs	r3, r0, #9
    995e:	428b      	cmp	r3, r1
    9960:	d301      	bcc.n	9966 <__udivsi3+0x8e>
    9962:	024b      	lsls	r3, r1, #9
    9964:	1ac0      	subs	r0, r0, r3
    9966:	4152      	adcs	r2, r2
    9968:	0a03      	lsrs	r3, r0, #8
    996a:	428b      	cmp	r3, r1
    996c:	d301      	bcc.n	9972 <__udivsi3+0x9a>
    996e:	020b      	lsls	r3, r1, #8
    9970:	1ac0      	subs	r0, r0, r3
    9972:	4152      	adcs	r2, r2
    9974:	d2cd      	bcs.n	9912 <__udivsi3+0x3a>
    9976:	09c3      	lsrs	r3, r0, #7
    9978:	428b      	cmp	r3, r1
    997a:	d301      	bcc.n	9980 <__udivsi3+0xa8>
    997c:	01cb      	lsls	r3, r1, #7
    997e:	1ac0      	subs	r0, r0, r3
    9980:	4152      	adcs	r2, r2
    9982:	0983      	lsrs	r3, r0, #6
    9984:	428b      	cmp	r3, r1
    9986:	d301      	bcc.n	998c <__udivsi3+0xb4>
    9988:	018b      	lsls	r3, r1, #6
    998a:	1ac0      	subs	r0, r0, r3
    998c:	4152      	adcs	r2, r2
    998e:	0943      	lsrs	r3, r0, #5
    9990:	428b      	cmp	r3, r1
    9992:	d301      	bcc.n	9998 <__udivsi3+0xc0>
    9994:	014b      	lsls	r3, r1, #5
    9996:	1ac0      	subs	r0, r0, r3
    9998:	4152      	adcs	r2, r2
    999a:	0903      	lsrs	r3, r0, #4
    999c:	428b      	cmp	r3, r1
    999e:	d301      	bcc.n	99a4 <__udivsi3+0xcc>
    99a0:	010b      	lsls	r3, r1, #4
    99a2:	1ac0      	subs	r0, r0, r3
    99a4:	4152      	adcs	r2, r2
    99a6:	08c3      	lsrs	r3, r0, #3
    99a8:	428b      	cmp	r3, r1
    99aa:	d301      	bcc.n	99b0 <__udivsi3+0xd8>
    99ac:	00cb      	lsls	r3, r1, #3
    99ae:	1ac0      	subs	r0, r0, r3
    99b0:	4152      	adcs	r2, r2
    99b2:	0883      	lsrs	r3, r0, #2
    99b4:	428b      	cmp	r3, r1
    99b6:	d301      	bcc.n	99bc <__udivsi3+0xe4>
    99b8:	008b      	lsls	r3, r1, #2
    99ba:	1ac0      	subs	r0, r0, r3
    99bc:	4152      	adcs	r2, r2
    99be:	0843      	lsrs	r3, r0, #1
    99c0:	428b      	cmp	r3, r1
    99c2:	d301      	bcc.n	99c8 <__udivsi3+0xf0>
    99c4:	004b      	lsls	r3, r1, #1
    99c6:	1ac0      	subs	r0, r0, r3
    99c8:	4152      	adcs	r2, r2
    99ca:	1a41      	subs	r1, r0, r1
    99cc:	d200      	bcs.n	99d0 <__udivsi3+0xf8>
    99ce:	4601      	mov	r1, r0
    99d0:	4152      	adcs	r2, r2
    99d2:	4610      	mov	r0, r2
    99d4:	4770      	bx	lr
    99d6:	e7ff      	b.n	99d8 <__udivsi3+0x100>
    99d8:	b501      	push	{r0, lr}
    99da:	2000      	movs	r0, #0
    99dc:	f000 f806 	bl	99ec <__aeabi_idiv0>
    99e0:	bd02      	pop	{r1, pc}
    99e2:	46c0      	nop			; (mov r8, r8)

000099e4 <__aeabi_uidivmod>:
    99e4:	2900      	cmp	r1, #0
    99e6:	d0f7      	beq.n	99d8 <__udivsi3+0x100>
    99e8:	e776      	b.n	98d8 <__udivsi3>
    99ea:	4770      	bx	lr

000099ec <__aeabi_idiv0>:
    99ec:	4770      	bx	lr
    99ee:	46c0      	nop			; (mov r8, r8)

000099f0 <__ctzsi2>:
    99f0:	4241      	negs	r1, r0
    99f2:	4008      	ands	r0, r1
    99f4:	211c      	movs	r1, #28
    99f6:	2301      	movs	r3, #1
    99f8:	041b      	lsls	r3, r3, #16
    99fa:	4298      	cmp	r0, r3
    99fc:	d301      	bcc.n	9a02 <__ctzsi2+0x12>
    99fe:	0c00      	lsrs	r0, r0, #16
    9a00:	3910      	subs	r1, #16
    9a02:	0a1b      	lsrs	r3, r3, #8
    9a04:	4298      	cmp	r0, r3
    9a06:	d301      	bcc.n	9a0c <__ctzsi2+0x1c>
    9a08:	0a00      	lsrs	r0, r0, #8
    9a0a:	3908      	subs	r1, #8
    9a0c:	091b      	lsrs	r3, r3, #4
    9a0e:	4298      	cmp	r0, r3
    9a10:	d301      	bcc.n	9a16 <__ctzsi2+0x26>
    9a12:	0900      	lsrs	r0, r0, #4
    9a14:	3904      	subs	r1, #4
    9a16:	a202      	add	r2, pc, #8	; (adr r2, 9a20 <__ctzsi2+0x30>)
    9a18:	5c10      	ldrb	r0, [r2, r0]
    9a1a:	1a40      	subs	r0, r0, r1
    9a1c:	4770      	bx	lr
    9a1e:	46c0      	nop			; (mov r8, r8)
    9a20:	1d1d1c1b 	.word	0x1d1d1c1b
    9a24:	1e1e1e1e 	.word	0x1e1e1e1e
    9a28:	1f1f1f1f 	.word	0x1f1f1f1f
    9a2c:	1f1f1f1f 	.word	0x1f1f1f1f

00009a30 <__libc_init_array>:
    9a30:	b570      	push	{r4, r5, r6, lr}
    9a32:	2600      	movs	r6, #0
    9a34:	4d0c      	ldr	r5, [pc, #48]	; (9a68 <__libc_init_array+0x38>)
    9a36:	4c0d      	ldr	r4, [pc, #52]	; (9a6c <__libc_init_array+0x3c>)
    9a38:	1b64      	subs	r4, r4, r5
    9a3a:	10a4      	asrs	r4, r4, #2
    9a3c:	42a6      	cmp	r6, r4
    9a3e:	d109      	bne.n	9a54 <__libc_init_array+0x24>
    9a40:	2600      	movs	r6, #0
    9a42:	f000 f821 	bl	9a88 <_init>
    9a46:	4d0a      	ldr	r5, [pc, #40]	; (9a70 <__libc_init_array+0x40>)
    9a48:	4c0a      	ldr	r4, [pc, #40]	; (9a74 <__libc_init_array+0x44>)
    9a4a:	1b64      	subs	r4, r4, r5
    9a4c:	10a4      	asrs	r4, r4, #2
    9a4e:	42a6      	cmp	r6, r4
    9a50:	d105      	bne.n	9a5e <__libc_init_array+0x2e>
    9a52:	bd70      	pop	{r4, r5, r6, pc}
    9a54:	00b3      	lsls	r3, r6, #2
    9a56:	58eb      	ldr	r3, [r5, r3]
    9a58:	4798      	blx	r3
    9a5a:	3601      	adds	r6, #1
    9a5c:	e7ee      	b.n	9a3c <__libc_init_array+0xc>
    9a5e:	00b3      	lsls	r3, r6, #2
    9a60:	58eb      	ldr	r3, [r5, r3]
    9a62:	4798      	blx	r3
    9a64:	3601      	adds	r6, #1
    9a66:	e7f2      	b.n	9a4e <__libc_init_array+0x1e>
    9a68:	00009a94 	.word	0x00009a94
    9a6c:	00009a94 	.word	0x00009a94
    9a70:	00009a94 	.word	0x00009a94
    9a74:	00009a98 	.word	0x00009a98

00009a78 <_usb_device_irq_bits>:
    9a78:	00080004 00800070 01000001 00000200     ....p...........

00009a88 <_init>:
    9a88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9a8a:	46c0      	nop			; (mov r8, r8)
    9a8c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9a8e:	bc08      	pop	{r3}
    9a90:	469e      	mov	lr, r3
    9a92:	4770      	bx	lr

00009a94 <__init_array_start>:
    9a94:	000080dd 	.word	0x000080dd

00009a98 <_fini>:
    9a98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9a9a:	46c0      	nop			; (mov r8, r8)
    9a9c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9a9e:	bc08      	pop	{r3}
    9aa0:	469e      	mov	lr, r3
    9aa2:	4770      	bx	lr

00009aa4 <__fini_array_start>:
    9aa4:	000080b5 	.word	0x000080b5
